<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Redis 基本数据结构（未完成）</title>
    <link href="/2022/02/09/Redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E6%9C%AA%E5%AE%8C%E6%88%90%EF%BC%89/"/>
    <url>/2022/02/09/Redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E6%9C%AA%E5%AE%8C%E6%88%90%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>回顾 Redis 底层的几种基本数据结构。</p><span id="more"></span><h2 id="简单动态字符串（Simple-Dynamic-String-SDS）"><a href="#简单动态字符串（Simple-Dynamic-String-SDS）" class="headerlink" title="简单动态字符串（Simple Dynamic String, SDS）"></a>简单动态字符串（Simple Dynamic String, SDS）</h2><p>Redis 自己封装的一种字符串操作抽象类型，能实现快捷的字符串修改和节省空间。</p><p>应用范围：所有涉及到字符串修改的操作，如：string、key、AOF 等</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sdshdr</span> &#123;</span>    <span class="hljs-comment">// 记录字符串长度，让查询字符串长度的时间复杂度为 O(1)</span>  <span class="hljs-keyword">int</span> len;  <span class="hljs-comment">// 记录数组中未使用字节的数量</span>  <span class="hljs-comment">// 确保在操作时很容易就能检测到缓冲区溢出的情况</span>  <span class="hljs-keyword">int</span> <span class="hljs-built_in">free</span>;  <span class="hljs-comment">// char 类型的字节数组，用于保存字符串</span>  <span class="hljs-comment">// 减少内存再分配的次数，减少系统调用，增加性能</span>  <span class="hljs-keyword">char</span> buf[];  &#125;</code></pre></div><p>SDS 遵循 C 的字符串规范，结尾的<code>\0</code>不会被算进总长度中。</p><p>注意，<code>len</code> + <code>free</code>不等于总的长度，因为<code>free</code>在记录空闲长度时，不会记录<code>\0</code>。</p><h3 id="SDS-空间拓展规则"><a href="#SDS-空间拓展规则" class="headerlink" title="SDS 空间拓展规则"></a>SDS 空间拓展规则</h3><ol><li>SDS 在更新字符串时发现空间不足时，会进行一次扩容</li><li>如果 buf 数组中，字符串长度小于 1MB 时，在执行空间拓展时，会分配与字符串长度相同的空间，即，在分配完成后，字符串的长度为：len + free + 1 = len * 2 + 1</li><li>如果 buf 数组中，字符串长度大于等于 1MB 时，在执行空间拓展时，会分配 1MB 的空间，即，在分配完成后，字符串的长度为：len + free + 1 = len + 1MB + 1</li></ol><h3 id="空间惰性释放"><a href="#空间惰性释放" class="headerlink" title="空间惰性释放"></a>空间惰性释放</h3><p>在删除字符串中的字符时，SDS 不会立即进行内存重分配。</p><p>与此同时，SDS 也提供了相应的 API，可以让我们在有需要时释放空间。</p><h3 id="二进制存储"><a href="#二进制存储" class="headerlink" title="二进制存储"></a>二进制存储</h3><p>所有的SDS API 都以二进制的形式来存储数据，因此，SDS 字符串能保存一系列二进制数据。</p><h2 id="链表（List）"><a href="#链表（List）" class="headerlink" title="链表（List）"></a>链表（List）</h2><p>Redis 双向链表实现。</p><p>应用范围：list、慢查询等</p><h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> &#123;</span>    <span class="hljs-comment">// 前置节点</span>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">prev</span>;</span>  <span class="hljs-comment">// 后置节点</span>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">next</span>;</span>  <span class="hljs-comment">// 节点值</span>  <span class="hljs-keyword">void</span> *value;  &#125; listNode;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> &#123;</span>    listNode *head;    listNode *tail;    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> len;  &#125; <span class="hljs-built_in">list</span>;</code></pre></div><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>双向链表、无环、头尾指针、记录长度、值多态</p><h2 id="字典（Dictionary）"><a href="#字典（Dictionary）" class="headerlink" title="字典（Dictionary）"></a>字典（Dictionary）</h2><p>使用 Hash 表作为底层实现的字典。</p><p>应用范围：数据库、hash、set 等</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>秒杀系统项目总结</title>
    <link href="/2022/01/30/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <url>/2022/01/30/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>高并发场景下的一些注意事项。</p><span id="more"></span><p>文中数据均使用 jmeter 和 Linux 中的 <code>top</code> 命令测试获得。</p><h2 id="性能瓶颈"><a href="#性能瓶颈" class="headerlink" title="性能瓶颈"></a>性能瓶颈</h2><p>性能瓶颈主要有两个，一个便是单体 Application Server Tomcat 的性能瓶颈，一个便是数据库的性能瓶颈。</p><p>对于应用服务器的性能瓶颈，目前我所了解的解决方法便有以下几点：</p><ol><li>横向拓展，增加 Application Server 数量，本质上就是增加服务器，让诸如 Nginx 一类的 HTTP Server 负载均衡来分摊请求</li><li>根据服务器的性能，对 Application Server 进行调参</li><li>升级单个服务器</li></ol><p>对于数据库的性能瓶颈，我所了解的解决方法有：</p><ol><li>搭建 MySQL 集群，使用诸如 mycat 的数据库读写分离 + 负载均衡管理中间件来降低单体数据库的负载</li><li>MySQL 调参优化</li><li>SQL 优化</li><li>加缓存，加消息队列等中间件</li></ol><h2 id="添加缓存"><a href="#添加缓存" class="headerlink" title="添加缓存"></a>添加缓存</h2><p>处理高并发，本质就是两种策略，一种是加服务器，另一种便是加缓存。</p><p>对于静态资源，有很多处理方式，比如 CDN 缓存服务器、浏览器缓存、页面缓存（不常用）、URL 缓存（不常用），此外，还有在业务代码层面的缓存添加，代码层面能添加的缓存方式则非常多，比如对象缓存、缓存预修改等，业务代码添加的缓存是减少数据库服务器负载的重要手段，以下介绍本人用到过的缓存实例。</p><h3 id="对象缓存"><a href="#对象缓存" class="headerlink" title="对象缓存"></a>对象缓存</h3><p>对于经常被访问，却又变化不大的数据库字段，比如商品列表、商品详情，直接缓存到 Redis，下次读取直接读缓存，如果缓存中没有才读数据库，这种缓存策略一般被称为对象缓存。</p><p>注意，当这些缓存数据被更新时，Redis 中的缓存也应当被更新，此处涉及到缓存数据与数据库数据的双写一致性，详情可看下文或进行搜索。</p><p>对象缓存，有效地解决了频繁调取数据库的情况，获取数据都是现在缓存中获取，十分有效地减少了 MySQL 的 <strong>读请求</strong>。</p><p>这种策略的不足之处也很明显，对于读请求，缓存能有效地降低数据库的读请求，但对于写请求，对象缓存则无能为力了。</p><h4 id="优化实例"><a href="#优化实例" class="headerlink" title="优化实例"></a>优化实例</h4><p>设备：2核4G云服务器，Tomcat 9.0 默认配置，Redis 默认配置，1核1G MySQL 服务器</p><p>接口：查询商品列表</p><p>并发策略：5000个线程并发轮询10次接口</p><p>添加缓存前：预热后，jmeter 测得 QPS 约为1306</p><p>添加缓存后：预热后，jmeter 测得 QPS 约为2884</p><h3 id="页面静态化"><a href="#页面静态化" class="headerlink" title="页面静态化"></a>页面静态化</h3><p>通俗地讲，将资源进行标记，让浏览器能够将这些资源缓存到本地，下次访问时，缓存到本地的资源则不需要再次请求获取。</p><p>具体的方法就是在响应头上加缓存相关的字段，比如<code>Cache-Control</code>，详情可浏览 HTTP 协议和 Nginx 相关内容。</p><p>拓展：对于静态资源，我们可以通过配置 HTTP 服务器，将多个静态资源请求合并为一个请求，避免占用过多的空闲连接数（但一般都会先交给 CDN 服务器进行静态资源处理，除此之外，一些 CDN 还会将动态请求自动分发到离用户最近的服务站点上，提升传输速度）</p><h2 id="秒杀流程优化"><a href="#秒杀流程优化" class="headerlink" title="秒杀流程优化"></a>秒杀流程优化</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>对于秒杀活动，由于是高并发场景，我们在进行数据库修改操作时，如果是生产平时的订单表，如果流程设计有缺陷、代码质量不足，或产生了由于并发量过大而导致的一些问题，比如库存超卖、同一个用户秒杀多次等问题，因此，需要健壮的数据库设计来进行兜底。</p><h4 id="独立建表"><a href="#独立建表" class="headerlink" title="独立建表"></a>独立建表</h4><p>对于秒杀活动生成的订单、参与秒杀的商品等秒杀业务涉及到的表，均可以独立建表，这样不仅能够在数据库层面将秒杀业务和普通订单的下单业务分离出来，减少对单个表的访问次数，减少创建销毁锁的消耗等，还能针对秒杀场景对秒杀订单表进行优化。</p><h4 id="建立唯一索引（秒杀业务场景特解）"><a href="#建立唯一索引（秒杀业务场景特解）" class="headerlink" title="建立唯一索引（秒杀业务场景特解）"></a>建立唯一索引（秒杀业务场景特解）</h4><p>秒杀的业务场景，通常只允许一个用户对一件商品成功秒杀一次，因此可以对用户id + 商品id 建立唯一索引，保证生成订单的唯一性。</p><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><p>在 update 时，添加健壮的 where 条件，比如当秒杀商品的库存大于0时才允许进行秒杀商品的减库存操作。</p><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>设计好秒杀流程的事务，保证在秒杀流程某一环节出错时，对一些关键操作进行回滚。</p><h4 id="订单"><a href="#订单" class="headerlink" title="订单"></a>订单</h4><p>对于已经生成成功的秒杀订单，我们可以先不用在订单表生成普通订单，而是拿缓存中订单商品的相关信息，先生成一个临时的普通订单缓存到 Redis，随后等待秒杀活动结束后，才将生成普通订单，并写入数据库，减少对秒杀商品订单、普通订单、秒杀商品的表的操作。</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>加 Redis 的本质，便是尽可能地减少访问数据库，因此，对于秒杀这一快速更改数据库的某一个字段的场景，我们需要进行对应的预处理，来减少进入秒杀时数据库的负载。</p><h4 id="秒杀商品库存预处理"><a href="#秒杀商品库存预处理" class="headerlink" title="秒杀商品库存预处理"></a>秒杀商品库存预处理</h4><p>系统初始化时，预先将商品库存数量加载到 Redis，收到请求时，优先减少 Redis 中的库存数量，如果 Redis 库存不足，直接返回，如果库存足够，在 Redis 中预减库存，并处理请求（放进消息队列中进行等待，返回给前端排队中的状态，后端根据数据库处理能力，依次处理数据，将订单、库存等更新信息更新到数据库中，于此同时，前端轮询访问是否秒杀成功，详情见下文）</p><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>在商品预处理时，可能会因为大量并发而导致 Redis 修改出现问题，虽然本项目不会出现问题，但对其它并发场景有着一些作用。</p><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p>RabbitMQ 是用 Erlang 语言开发的消息队列中间件，本文章使用 RabbitMQ 版本为 3.9.13</p><p><a href="https://hub.docker.com/_/rabbitmq/">Docker</a>：</p><div class="code-wrapper"><pre><code class="hljs bash">docker run -d --hostname my-rabbit --name rabbit_self -p 15672:15672 -p 5672:5672 rabbitmq:3.9.13-management</code></pre></div><h4 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h4><p><a href="https://www.rabbitmq.com/getstarted.html">官方文档</a></p><p><a href="https://www.cnblogs.com/linyufeng/p/9885020.html">四种交换机模式</a></p><p>在秒杀流程中，使用 RabbitMQ 对数据库访问请求频繁的接口进行削峰，减少对数据库的负载。</p><h3 id="优化后的秒杀流程"><a href="#优化后的秒杀流程" class="headerlink" title="优化后的秒杀流程"></a>优化后的秒杀流程</h3><p>系统初始化，把商品库存存入 Redis （InitializingBean）</p><p>收到请求，Redis 预减库存，库存不足，直接返回失败（Redis）</p><p>减少库存后，将请求入队，返回排队中（MQ）</p><p>请求出队，收到请求后生成订单，减少库存，并将订单写入缓存（MySQL Redis）</p><p>客户端轮询，查看是否生成订单来判断是否秒杀成功（Redis）</p><p>简易代码逻辑：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 处理秒杀的核心方法简略代码</span><span class="hljs-comment"> * TODO 如果 Redis 预减库存小于0，把对应的 goodId 写入 Guava 缓存中，先读缓存，存在则直接返回，减少访问 Redis 次数</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">handleFlashRequest</span><span class="hljs-params">(String userId, String goodId)</span> </span>&#123;  <span class="hljs-comment">// 预减库存，使用分布式锁(此处直接将部分代码移到此处，其实这里也不用加分布式锁，只是为了熟悉加锁操作罢了)</span><span class="hljs-comment">// GoodKey 是定义生成对应 Redis Key 格式的类</span>  <span class="hljs-keyword">long</span> timeMills = System.currentTimeMills();  <span class="hljs-keyword">long</span> limitTime = <span class="hljs-number">1000L</span>;  <span class="hljs-keyword">while</span> (defaultRedisService.setNx(LockKey.getFlashLockKey(goodId),                                    userId,                                    limitTime,                                    TimeUnit.MILLISECONDS)) &#123;    <span class="hljs-keyword">if</span> (System.currentTimeMills() - timeMills &gt;= limitTime) &#123;      <span class="hljs-keyword">break</span>;    &#125;  &#125;<span class="hljs-keyword">try</span> &#123;  <span class="hljs-keyword">if</span> (defaultRedisService.decr(GoodKey.getStockKey(goodId)) &lt; <span class="hljs-number">0</span>) &#123;    <span class="hljs-comment">// TODO 在 Response 添加对 ErrorCode 的统一转译处理</span>    <span class="hljs-keyword">return</span> Response.buildFailure(GoodErrorCode.MAX_NUM.getCode(), GoodErrorCode.MAX_NUM.getDescription());  &#125;&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;  <span class="hljs-comment">// 防止超出 Long 范围而抛出异常</span>  <span class="hljs-comment">// GoodsErrorCode 实现了一个带有 getCode 和 getDescription 方法的 MessageCode 接口</span>  <span class="hljs-keyword">return</span> Response.buildFailure(GoodErrorCode.MAX_NUM.getCode(), GoodErrorCode.MAX_NUM.getDescription());&#125; <span class="hljs-keyword">finally</span> &#123;    defaultRedisService.getDel(LockKey.getFlashLockKey(goodId));  &#125;<span class="hljs-comment">// 生成入队对象，此处忽略值填充</span>FlashDO flashDO = <span class="hljs-keyword">new</span> FlashDO();<span class="hljs-comment">// 入队</span>mqSender.sendFlashRequestMessage(flashDO);<span class="hljs-comment">// 返回成功状态</span><span class="hljs-keyword">return</span> Response.buildSuccess();&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 处理出队后的简略代码（异步）</span><span class="hljs-comment"> */</span><span class="hljs-meta">@RabbitListener(queues=MQMessage.FLASH_QUEUE)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleReceivedFlashRequest</span><span class="hljs-params">(String message)</span> </span>&#123;  <span class="hljs-comment">// 还原为 DO</span>  FlashDO flashDO = <span class="hljs-keyword">new</span> Gson().fromJson(message, FlashDO.class);  <span class="hljs-comment">// 由于经过消息队列的削峰，在此处进行数据库操作就比较友好，此处详细的数据库操作</span>    <span class="hljs-comment">// 秒杀订单重复校验、秒杀商品库存校验，没有过校验，直接返回</span>    <span class="hljs-comment">// 秒杀订单对象生成，忽略值填充</span>  flashOrderEntity = <span class="hljs-keyword">new</span> FlashGoodsEntity();    <span class="hljs-comment">// 减库存成功后，写入秒杀订单表，写入成功后，将秒杀订单写入 Redis</span>  <span class="hljs-keyword">if</span> (flashGoodsService.insert(flashOrderEntity)) &#123;    String redisKey = FlashOrderKey.getOrderKey(flashDO.getUserId, flashDO.getGoodId);    defaultRedisService.set(redisKey, flashOrderEntity);  &#125;  &#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 间隔一定时间轮询获取秒杀结果</span><span class="hljs-comment"> * TODO 轮询获取一定次数或时间后，如果仍然拿不到订单，则调用另一个查秒杀订单数据库的方法</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> SingleResponse&lt;flashResultCO&gt; <span class="hljs-title">getFlashResult</span><span class="hljs-params">(String userId, String goodId)</span> </span>&#123;  <span class="hljs-comment">// 从 Redis 中获取订单信息</span>  FlashOrderEntity flashOrderEntity =     defaultRedisService.get(FlashOrderKey.getOrderKey(userId, goodId), FlashOrderEntity.class);    <span class="hljs-comment">// 创建生成结果对象，忽略值填充</span>  FlashResultCO flashResultCO = <span class="hljs-keyword">new</span> FlashResultCO();    <span class="hljs-comment">// 定义订单状态</span>  String orderStatusCode = ObjectUtil.isNull(flashOrderEntity) ?     FlashOrderStatus.NULL.getCode() : FlashOrderStatus.SUCCEED.getCode();  flashResultCO.setOrderStatusCode(orderStatusCode);  <span class="hljs-comment">// 返回订单结果</span>  <span class="hljs-keyword">return</span> SingleResponse.of(flashResultCO);  &#125;</code></pre></div><h4 id="优化实例-1"><a href="#优化实例-1" class="headerlink" title="优化实例"></a>优化实例</h4><p>设备：2核4G云服务器，Tomcat 9.0 默认配置，Redis 默认配置，RabitMQ 默认配置，1核1G MySQL 服务器</p><p>接口：库存为1000的商品秒杀</p><p>并发策略：5000个线程并发轮询10次接口</p><p>添加缓存前：预热后，jmeter 测得 QPS 约为1217</p><p>添加缓存后：预热后，jmeter 测得 QPS 约为2114</p><p>此处由于服务器性能限制，QPS 始终无法上升，因为 Tomcat、Redis、RabbitMQ 都在一台服务器内，同时占用了大量 CPU 和内存。</p><h3 id="高并发的其它优化方法"><a href="#高并发的其它优化方法" class="headerlink" title="高并发的其它优化方法"></a>高并发的其它优化方法</h3><h4 id="七层负载均衡"><a href="#七层负载均衡" class="headerlink" title="七层负载均衡"></a>七层负载均衡</h4><p>利用 Nginx 等 HTTP Server，通过反向代理多个分布式微服务，实现负载均衡，详情可见博客中的 Nginx 笔记文章。</p><p>其次，如果一台 HTTP Server 也已经无法负载这么多的请求了，可以使用 Linux Vitural Server，来横向拓展 HTTP Server，通常这个负载均衡策略在处理千万级别以上的请求才会使用到。</p><p>拓展：<a href="https://blog.csdn.net/weixin_40470303/article/details/80541639">高效的负载均衡策略：LVS</a></p><h4 id="接口地址隐藏"><a href="#接口地址隐藏" class="headerlink" title="接口地址隐藏"></a>接口地址隐藏</h4><p>以秒杀系统为例：在点击秒杀按钮的时候，不直接调用秒杀接口，而是调用获取秒杀地址的接口获取一个验证码，再调用秒杀接口时再传入这个验证码作为随机路径参数，验证通过后才进行秒杀操作。</p><p>示例代码：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/* 下列方法可以使用其它方式实现，这里仅仅提供一个简单的思路和解法 */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * 获取秒杀路径的方法</span><span class="hljs-comment"> * 省略参数校验</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> SingleResponse&lt;String&gt; <span class="hljs-title">getFlashVerifyCode</span><span class="hljs-params">(String goodId, String userId)</span> </span>&#123;  <span class="hljs-comment">// 生成验证码，存入 Redis</span>  String verifyCode = UUIDUtil.getRandomUUID();  defaultRedisService.setNx(VerifyCodeKey.getVerifyKey(userId, goodId),                             verifyCode,                             <span class="hljs-number">60L</span>,                             TimeUnit.SECONDS);  <span class="hljs-comment">// 组装路径，最后返回</span>  String flashPath = createFlashPath(userId, goodId, verifyCode);  <span class="hljs-keyword">return</span> SingleResponse.of(flashPath);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 修改秒杀服务，省略其它业务代码</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">handleFlashRequest</span><span class="hljs-params">(String userId, String goodId, String verifyCode)</span> </span>&#123;  <span class="hljs-comment">// 判断是否存在该验证码</span>  String code = defaultRedisService.get(VerifyCodeKey.getVerifyKey(userId, goodId));  <span class="hljs-keyword">if</span> (StrUtil.isEmpty(code) || !code.equal(verifyCode)) &#123;    <span class="hljs-keyword">return</span> Response.buildFailure(FlashErrorCode.VERIFY_FAIL.getCode(),                                  FlashErrorCode.VERIFY_FAIL.getDescription());  &#125;    <span class="hljs-comment">// 省略其它业务代码...</span>&#125;</code></pre></div><h4 id="接口限流防刷"><a href="#接口限流防刷" class="headerlink" title="接口限流防刷"></a>接口限流防刷</h4><p>以秒杀系统为例：隐藏了接口地址，能过滤一般的恶意请求，如果别人恶意刷参数校验的接口，也会造成一些影响，因此，增加限流防刷能有效减少恶意请求数量。</p><p>主要实现就是 Redis 的 setex 和 exists。</p><p>主要实现代码：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@Documented</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AccessLimit &#123;  <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">seconds</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">maxCount</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">needLogin</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">true</span></span>;&#125;<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessLimitInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;    <span class="hljs-meta">@Resource</span>  <span class="hljs-keyword">private</span> DefaultRedisService defaultRedisService;    <span class="hljs-meta">@Resource</span>  <span class="hljs-keyword">private</span> UserService userService;    <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(<span class="hljs-meta">@Nonnull</span> HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">                           <span class="hljs-meta">@Nonnull</span> HttpServletResponse response,</span></span><span class="hljs-function"><span class="hljs-params">                           <span class="hljs-meta">@Nonnull</span> Object handler)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!(handler <span class="hljs-keyword">instanceof</span> HandlerMethod)) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    AccessLimit accessLimit = ((HandlerMethod) handler).getMethodAnnotation(AccessLimit.class);    <span class="hljs-keyword">if</span> (accessLimit == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">long</span> seconds = accessLimit.seconds();    <span class="hljs-keyword">long</span> maxCount = accessLimit.maxCount();    <span class="hljs-keyword">if</span> (accessLimit.needLogin()) &#123;          &#125;  &#125;  &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Java Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx笔记（未完成）</title>
    <link href="/2022/01/16/Nginx%E7%AC%94%E8%AE%B0%EF%BC%88%E6%9C%AA%E5%AE%8C%E6%88%90%EF%BC%89/"/>
    <url>/2022/01/16/Nginx%E7%AC%94%E8%AE%B0%EF%BC%88%E6%9C%AA%E5%AE%8C%E6%88%90%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本文主要整理 Nginx 学习中的一些重要知识点。</p><p>本文中测试环境部分为 Nginx 官方 Docker 镜像，Nginx 版本：1.20.5</p><span id="more"></span><h2 id="Nginx-容器相关"><a href="#Nginx-容器相关" class="headerlink" title="Nginx 容器相关"></a>Nginx 容器相关</h2><h3 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h3><h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> nginx:stable<span class="hljs-keyword">VOLUME</span><span class="bash"> [ <span class="hljs-string">&quot;/var/log/error.log&quot;</span>, <span class="hljs-string">&quot;/var/run/&quot;</span>, <span class="hljs-string">&quot;/etc/nginx&quot;</span>, <span class="hljs-string">&quot;/usr/share/nginx&quot;</span>]</span><span class="hljs-keyword">COPY</span><span class="bash"> ./application.conf /etc/nginx/conf.d/</span><span class="hljs-keyword">COPY</span><span class="bash"> ./nginx.conf /etc/nginx/nginx.conf</span></code></pre></div><h4 id="nginx-conf"><a href="#nginx-conf" class="headerlink" title="nginx.conf"></a>nginx.conf</h4><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">user</span>  nginx;<span class="hljs-attribute">worker_processes</span>  auto;<span class="hljs-attribute">error_log</span>  /var/log/nginx/error.log <span class="hljs-literal">notice</span>;<span class="hljs-attribute">pid</span>        /var/run/nginx.pid;<span class="hljs-section">events</span> &#123;    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>;&#125;<span class="hljs-section">http</span> &#123;    <span class="hljs-attribute">include</span>       /etc/nginx/mime.types;    <span class="hljs-attribute">default_type</span>  application/octet-stream;    <span class="hljs-attribute">log_format</span>  main  <span class="hljs-string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span>                      <span class="hljs-string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span>                      <span class="hljs-string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;    <span class="hljs-attribute">access_log</span>  /var/log/nginx/access.log  main;    <span class="hljs-attribute">sendfile</span>        <span class="hljs-literal">on</span>;    <span class="hljs-comment">#tcp_nopush     on;</span>    <span class="hljs-attribute">keepalive_timeout</span>  <span class="hljs-number">65</span>;    <span class="hljs-comment">#gzip  on;</span>        <span class="hljs-attribute">include</span> /etc/nginx/conf.d/application.conf;&#125;</code></pre></div><h4 id="application-conf"><a href="#application-conf" class="headerlink" title="application.conf"></a>application.conf</h4><p>用于连接远程服务器的 Application Server</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">upstream</span> application &#123;    <span class="hljs-attribute">server</span> ip:port;    <span class="hljs-attribute">keepalive</span> <span class="hljs-number">32</span>;    <span class="hljs-attribute">keepalive_requests</span> <span class="hljs-number">100</span>;    <span class="hljs-attribute">keepalive_timeout</span> <span class="hljs-number">60s</span>;&#125;<span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">listen</span> *:<span class="hljs-number">80</span>;    <span class="hljs-attribute">server_name</span> localhost;    <span class="hljs-attribute">location</span> / &#123;        <span class="hljs-attribute">proxy_pass</span> http://application/;    &#125;&#125;</code></pre></div><h4 id="Docker-CMD"><a href="#Docker-CMD" class="headerlink" title="Docker CMD"></a>Docker CMD</h4><div class="code-wrapper"><pre><code class="hljs bash">docker build -t nginx:self .docker run --name nginx_self -p 80:80 -d nginx:self</code></pre></div><h3 id="使用命令查看-Nginx-相关路径"><a href="#使用命令查看-Nginx-相关路径" class="headerlink" title="使用命令查看 Nginx 相关路径"></a>使用命令查看 Nginx 相关路径</h3><div class="code-wrapper"><pre><code class="hljs bash">nginx -h</code></pre></div><h2 id="Beginner’s-Guide"><a href="#Beginner’s-Guide" class="headerlink" title="Beginner’s Guide"></a><a href="https://nginx.org/en/docs/beginners_guide.html">Beginner’s Guide</a></h2><p>nginx has one master process and several worker processes. The main purpose of the master process is to read and evaluate configuration, and maintain worker processes.</p><p>Nginx 拥有一个主进程和一些工作进程，主进程的作用主要是读取并校验配置文件，并维护工作进程。</p><p>nginx employs event-based model and OS-dependent mechanisms to efficiently distribute requests among worker processes.</p><p>Nginx 采用基于事件的模型，并且依赖操作系统的机制来有效地在工作进程间分配请求。</p><p>To start nginx, run the executable file. Once nginx is started, it can be controlled by invoking the executable with the <code>-s</code> parameter. Use the following syntax:</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># -s means -singal</span>nginx -s signal</code></pre></div><p>Where <em>signal</em> may be one of the following:</p><ul><li><p><code>stop</code> — fast shutdown</p><p>快速关闭</p></li><li><p><code>quit</code> — graceful shutdown</p><p>等待工作进程处理完毕之后关闭</p></li><li><p><code>reload</code> — reloading the configuration file</p><p>重新加载配置文件，当主进程导入配置文件并且成功，Nginx 会重新启动新的工作进程，并发送信息给旧的工作进程，让他们完成任务后 shut down，期间，旧的工作进程不会接受新的请求。如果失败则回滚，使用原来的工作进程。</p></li><li><p><code>reopen</code> — reopening the log files</p></li></ul><p>For getting the list of all running nginx processes, the <code>ps</code> utility may be used, for example, in the following way:</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># invalid in container</span>ps -ax | grep nginx</code></pre></div><h2 id="nginx-conf-1"><a href="#nginx-conf-1" class="headerlink" title="nginx.conf"></a>nginx.conf</h2><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-comment"># 如果主进程使用root运行，那么nginx 将会调用 setuid()/setgid() 去设置 user/group。</span><span class="hljs-comment"># 如果 group 没有特别指定，那么 nginx 会使用 user 相同的名称设置 group。</span><span class="hljs-comment"># 默认为 nobody nogroup 或者安装nginx的时候在 ./configure 指定的 --user=USER 和 --group=GROUP</span><span class="hljs-attribute">user</span> nginx;<span class="hljs-attribute">pid</span> /run/nginx.pid;<span class="hljs-comment"># 指定异常退出后生层 core 文件 大小 位置</span><span class="hljs-comment"># worker_rlimit_core 50M;</span><span class="hljs-comment"># worker_directory /etc/nginx/temp</span><span class="hljs-comment"># 指定 Nginx 的工作进程个数（可用auto）</span><span class="hljs-attribute">worker_processes</span> <span class="hljs-number">2</span>;<span class="hljs-comment"># 指定 worker 子进程最大句柄数，linux 默认最大句柄数为 65535</span><span class="hljs-attribute">worker_rlimit_nofile</span> <span class="hljs-number">1024</span>;<span class="hljs-comment"># 绑定 Nginx 工作进程到某个 CPU</span><span class="hljs-comment"># 好处：减少进程在不同CPU间上下文切换所浪费的资源，充分利用 CPU 缓存</span><span class="hljs-comment"># 注意：此处意思并不是完全避免进程上下文切换</span><span class="hljs-comment"># 两个物理核心，两个 worker 进程，诸如以下示例</span><span class="hljs-attribute">worker_cpu_affinity</span> <span class="hljs-number">01</span> <span class="hljs-number">10</span>;<span class="hljs-comment"># 两个物理核心，四个 worker 进程</span><span class="hljs-comment"># 意思就是第一三个进程用一个核心，二四进程用另一个核心</span><span class="hljs-comment"># worker_cpu_affinity 01 10 01 10</span><span class="hljs-comment"># 指定工作进程 nice 值，调整 nginx 进程优先级，通常设定为负值，以优先调用nginx</span><span class="hljs-comment"># linux 默认优先级为 120，值越小越优先，nice 设定范围 -20 ～ 19</span><span class="hljs-comment"># priority = 120 + nice</span><span class="hljs-attribute">worker_priority</span> -<span class="hljs-number">10</span>;<span class="hljs-comment"># 指定 worker 进程优雅退出的超时时间</span><span class="hljs-comment"># worker_shutdown_timeout 5s;</span><span class="hljs-comment"># 指定 worker 子进程内部调用内核态计时器的时间，调整时间间隔越大，系统调用越少，有利于性能提升</span><span class="hljs-attribute">timer_resolution</span> <span class="hljs-number">100ms</span>;<span class="hljs-comment"># 开启守护进程</span><span class="hljs-attribute">daemon</span> <span class="hljs-literal">on</span>;<span class="hljs-comment"># 负载均衡锁文件默认配置</span><span class="hljs-comment"># lock_file logs/nginx.lock;</span></code></pre></div><h4 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h4><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog7-0.png" alt="客户端请求流程"></p><p>用户向服务器发起请求，网卡接收到请求，内核态通过 TCP/IP 解析 IP 和端口，找到对应监听这个 IP 和端口的程序，程序进程进行处理。过程中，程序会获取内核态的一些信息，比如计时器等，由于工作进程在用户态，因此内核态和用户态的切换会消耗资源。</p><h3 id="events"><a href="#events" class="headerlink" title="events"></a>events</h3><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-section">events</span> &#123;  <span class="hljs-comment"># 使用 linux 的io复用模型</span>  <span class="hljs-comment"># 推荐默认</span>  <span class="hljs-comment"># use epoll;</span>    <span class="hljs-comment"># 每个 worker 子进程的最大连接数</span>  <span class="hljs-comment"># 推荐 65535 / worker_processes || 65535</span>  <span class="hljs-comment"># 注意，上面定义了worker进程的句柄数，不要超过</span>  <span class="hljs-attribute">worker_connections</span> <span class="hljs-number">1024</span>;    <span class="hljs-comment"># 开启负载均衡锁</span>  <span class="hljs-comment"># 当关闭时，master 给所有 worker 都发一次信号，唤醒所有 worker 来争抢这个请求</span>  <span class="hljs-comment"># 打开时，相当于让 worker 串行获取请求的锁，其它进程就获取不到这个请求了</span>  <span class="hljs-comment"># 推荐打开</span>  <span class="hljs-attribute">accept_mutex</span> <span class="hljs-literal">on</span>;    <span class="hljs-comment"># 如果负载均衡给一个 worker，但超时指定时间不响应，master 就分发给其他 worker</span>  <span class="hljs-attribute">accept_mutex_delay</span> <span class="hljs-number">200ms</span>;    <span class="hljs-comment"># 让 worker 子进程在同一时刻接收多个请求</span>  <span class="hljs-attribute">multi_accept</span> <span class="hljs-literal">on</span>;  &#125;</code></pre></div><h4 id="补充知识-1"><a href="#补充知识-1" class="headerlink" title="补充知识"></a>补充知识</h4><p><a href="https://blog.csdn.net/adams_wu/article/details/51669203">accept_mutex 详解</a></p><p><a href="https://blog.csdn.net/wteruiycbqqvwt/article/details/90299610">IO复用技术</a></p><h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-section">http</span> &#123;  <span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;    <span class="hljs-comment"># 注意。其中的 server_name 的选择是根据请求头中的 host （或者https中的:authority）字段来判断</span>    <span class="hljs-attribute">server_name</span> www.rootzwy.com;    <span class="hljs-attribute">root</span> html/domain_vm1;    <span class="hljs-attribute">location</span> / &#123;      <span class="hljs-attribute">index</span> index.html;    &#125;  &#125;&#125;</code></pre></div><h4 id="补充知识-2"><a href="#补充知识-2" class="headerlink" title="补充知识"></a>补充知识</h4><p>root 和 alias 的区别：root 作用域比 alias 大，且 root 在寻找磁盘文件时会在后面加上 location 后的路径，而 alias 不会。</p><h3 id="location"><a href="#location" class="headerlink" title="location"></a>location</h3><table><thead><tr><th>匹配规则</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>=</td><td>精确匹配，匹配优先级最高</td><td>location = /images/ {}</td></tr><tr><td>~</td><td>区分大小写正则匹配，优先级第三高</td><td>location ~ \.(jpg|gif)$ {}</td></tr><tr><td>~*</td><td>不区分大小写正则匹配，优先级第四高</td><td>location ~* \.(jpg|gif)$ {}</td></tr><tr><td>^~</td><td>匹配到停止搜索，比如：/images?id=11&amp;name=11，优先级第二高</td><td>location ^~ /images/ {}</td></tr><tr><td>不带符号</td><td></td><td>location / {}</td></tr></tbody></table><h4 id="补充知识-3"><a href="#补充知识-3" class="headerlink" title="补充知识"></a>补充知识</h4><p>location 中带不带斜杠的区别</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-section">http</span> &#123;  <span class="hljs-attribute">root</span> html;  <span class="hljs-section">server</span> &#123;    <span class="hljs-comment"># 按照目录匹配，如果不存在，也不会按照文件匹配</span>    <span class="hljs-attribute">location</span> /img/ &#123;          &#125;&#125;  <span class="hljs-section">server</span> &#123;    <span class="hljs-comment"># 首先按目录进行匹配，如果匹配失败，将img按文件匹配</span>    <span class="hljs-attribute">location</span> /img &#123;          &#125;  &#125;&#125;</code></pre></div><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog7-1.png" alt="img"></p><p>反向代理在生产环境中是很常用的实现负载均衡的一个手段，也是处理动态请求的常用方法。</p><h3 id="反向代理优势"><a href="#反向代理优势" class="headerlink" title="反向代理优势"></a>反向代理优势</h3><p>隐藏真实服务器，实现 Application 的封装。</p><p>便于横向拓展后端动态服务。</p><p>动静分离，提升系统健壮性。</p><h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><p>指的是静态资源请求直接由 nginx 服务器返回，动态请求则按一定的策略分发给反向代理的 Application Server，Application Server 处理完请求后，发送给 nginx ，nginx 再将请求回传给用户。</p><p>除此之外，反向代理的好处就是实现 Application Server、Nginx（HTTP Server）、Client 之间传输协议的解耦，用户可以用 http 请求访问 nginx ，而 nginx 可以用 grpc 等其他协议与 Application Server 交互。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>在 conf.d 目录下创建 app_server，创建一个简易的应用服务器（此处可以替换为Application Server）</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">listen</span> <span class="hljs-number">8080</span>;    <span class="hljs-attribute">server_name</span> localhost;       <span class="hljs-attribute">location</span> /proxy/ &#123;        <span class="hljs-attribute">root</span> /opt/nginx/html/app;        <span class="hljs-attribute">index</span> proxy.html;    &#125;&#125;</code></pre></div><p>在另一个nginx上配置反向代理：</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">upstream</span> upstreamName &#123;    <span class="hljs-attribute">server</span> ip:port weight <span class="hljs-number">3</span> max_conns=<span class="hljs-number">1000</span> fail_timeout=<span class="hljs-number">10s</span> max_fails=<span class="hljs-number">3</span>;    <span class="hljs-attribute">keepalive</span> <span class="hljs-number">32</span>;    <span class="hljs-attribute">keepalive_requests</span> <span class="hljs-number">80</span>;    <span class="hljs-attribute">keepalive_time_out</span> <span class="hljs-number">20s</span>;&#125;<span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;    <span class="hljs-attribute">server_name</span> name;        <span class="hljs-comment"># 史前巨坑，在 location 路径存在时（如：/ali），spring boot 2.6.1 会显示 url 错误，报错为：存在两条下划线（如：//security/..），若 location 为 / 时正常运行，除此之外，如果 Spring Boot 没有 指定 mvc context，也无法正常运行。</span>    <span class="hljs-attribute">location</span> /path &#123;        <span class="hljs-attribute">proxy_pass</span> http://upstreamName/;    &#125;   &#125;</code></pre></div><p>proxy_pass 加不加 / 的区别</p><p>加 / 会自动去掉 location 中的 path，然后上传到上游服务器。不加，则 path 原封不动，上传到上游服务器。 </p><h3 id="proxy-request-buffering"><a href="#proxy-request-buffering" class="headerlink" title="proxy_request_buffering"></a>proxy_request_buffering</h3><p>作用域：http、server、location</p><p>默认值：on</p><p>nignx 开启缓冲区，用于缓存请求体，等待接收请求发送完毕再发送至 Application Server，能减少上游服务器的并发量。</p><p>除此之外，开启缓冲区还能减少磁盘 IO</p><h3 id="client-max-body-size"><a href="#client-max-body-size" class="headerlink" title="client_max_body_size"></a>client_max_body_size</h3><p>作用域：http、server、location</p><p>默认值：1M</p><p>根据 Content-Length 判断，大于该参数则返回 412 Response，如果小于，则存储到内存中。</p><h3 id="client-body-buffer-size"><a href="#client-body-buffer-size" class="headerlink" title="client_body_buffer_size"></a>client_body_buffer_size</h3><p>作用域：http、server、location</p><p>默认值：8k | 16k </p><h3 id="client-body-in-single-buffer"><a href="#client-body-in-single-buffer" class="headerlink" title="client_body_in_single_buffer"></a>client_body_in_single_buffer</h3><p>作用域：http、server、location</p><p>默认值：off</p><p>让请求体在内存中尽量按照顺序存储，减少读取开销。</p><p><strong>还有许多有用的指令，待以后补充……</strong></p><h2 id="HTTP请求更改"><a href="#HTTP请求更改" class="headerlink" title="HTTP请求更改"></a>HTTP请求更改</h2><h3 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h3><p>proxy_method</p><p>proxy_http_version</p><h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><p>proxy_set_header</p><p>默认：</p><p>proxy_set_header Host $proxy_host</p><p>proxy_set_header Connection close</p><p>proxy_pass_request_header</p><p>默认：on</p><h3 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h3><p>proxy_set_body</p><p>proxy_pass_request_body</p>]]></content>
    
    
    <categories>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git常用命令速览复习</title>
    <link href="/2021/11/08/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E8%A7%88%E5%A4%8D%E4%B9%A0/"/>
    <url>/2021/11/08/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E8%A7%88%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>Git 常用命令速览复习。</p><span id="more"></span><p>参考教程：<a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰 Git 教程</a></p><div class="code-wrapper"><pre><code class="hljs bash">git init <span class="hljs-comment"># 创建仓库</span>git add filename1, [filename2] <span class="hljs-comment"># 将文件添加至 git 管理</span>git commit -m <span class="hljs-string">&quot;msg&quot;</span> <span class="hljs-comment"># 提交文件修改,一次提交仓库内的多个文件</span>git status <span class="hljs-comment"># 掌握仓库当前的状态</span>git diff filename <span class="hljs-comment"># 查看未提交文件的修改</span>git <span class="hljs-built_in">log</span> <span class="hljs-comment"># 查看提交日志 </span>git reset  --hard HEAD^ <span class="hljs-comment"># 版本更改，在 Git 中，用 HEAD 表示当前版本，上一个版本就是 HEAD^ ，上上一个版本就是 HEAD^^ ，当然往上100个版本写100个 ^ 比较容易数不过来，所以写成 HEAD~100，或者直接通过 commit id 来更改</span>git reflog <span class="hljs-comment"># 查看历史命令日志</span></code></pre></div><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是 Git 的版本库。</p><p>Git 的版本库里存了很多东西，其中最重要的就是称为 stage（或者叫 index ）的暂存区，还有 Git 自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p><p>前面把文件往 Git 版本库里添加的时候，是分两步执行的：</p><p>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p><p>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p><p>因此，务必要将修改或添加的文件添加至暂存区才能进行提交。</p><div class="code-wrapper"><pre><code class="hljs bash">git restore filename <span class="hljs-comment"># 将文件在工作区的修改全部撤销，要么撤销到暂存区的状态，要么撤销到版本库的状态</span></code></pre></div><p>这里有两种情况：</p><p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><p>如果你的文件已经通过<code>git add</code>提交到暂存区：</p><div class="code-wrapper"><pre><code class="hljs bash">git restore --staged filename <span class="hljs-comment"># 将暂存区中的文件撤销，重新放回工作区（如果工作区文件又进行了修改，则不会覆盖）</span></code></pre></div><p>删除文件：</p><div class="code-wrapper"><pre><code class="hljs bash">git rm filename <span class="hljs-comment"># 删除已经提交的文件（需要重新提交）</span></code></pre></div><p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p><div class="code-wrapper"><pre><code class="hljs bash">git checkout -- test.txt</code></pre></div><p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><p>远程仓库设置：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 创建用户名和邮箱</span>git config --global user.name <span class="hljs-string">&quot;yourname&quot;</span>git config --global user.email <span class="hljs-string">&quot;your_email@youremail.com&quot;</span><span class="hljs-comment"># 生成秘钥</span>ssh-keygen -t rsa -C <span class="hljs-string">&quot;your_email@youremail.com&quot;</span><span class="hljs-comment"># 添加远程仓库</span><span class="hljs-comment"># 远程库的名字就是 origin，这是 Git 默认的叫法，也可以改成别的</span>git remote add origin https://github.com/RoOtZwY/git-learning.git<span class="hljs-comment"># 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。</span><span class="hljs-comment"># 由于远程库为空，第一次推送 master 分支时，加上-u参数，会把本地的 master 分支内容推送的远程新的 master 分支，还会把本地的master分支和远程的master分支关联，在以后的推送或者拉取时就可以简化命令。</span>git push -u origin master<span class="hljs-comment"># 提交到 master 后 push 到远程仓库</span>git push origin master<span class="hljs-comment"># 查看远程库信息</span>git remote -v<span class="hljs-comment"># 根据名字删除，比如删除origin</span>git remote rm origin</code></pre></div><p>远程仓库克隆：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 将远程仓库克隆到当前文件夹</span>git <span class="hljs-built_in">clone</span> git@github.com:用户名/仓库名</code></pre></div><p>GitHub给出的地址不止一个，还可以用<code>https://github.com/用户名/仓库名</code>这样的地址。实际上，Git支持多种协议，默认的<code>git://</code>使用<code>SSH</code>，但也可以使用<code>HTTPS</code>等其他协议。</p><p>使用<code>HTTPS</code>除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用<code>SSH</code>协议而只能用<code>HTTPS</code>。</p><p>分支管理：</p><p>Git鼓励大量使用分支。</p><p>在版本回退里，每次提交，Git 都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在 Git 里，这个分支叫主分支，即<code>master</code>分支。<code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的就是当前分支。</p><p>当创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上。</p><p>不过，从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变。</p><p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并。</p><p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 创建并切换到dev分支</span>git checkout -b dev<span class="hljs-comment"># git checkout 命令加上 -b 参数表示创建并切换，相当于:</span><span class="hljs-comment"># 创建</span>git branch dev<span class="hljs-comment"># 切换</span>git checkout dev<span class="hljs-comment"># 新版本的Git提供了新的git switch命令来切换分支</span>git switch dev<span class="hljs-comment"># 列出所有分支</span>git branch<span class="hljs-comment"># 合并指定分支到当前分支</span>git merge 指定分支<span class="hljs-comment"># 删除分支</span>git branch -d dev<span class="hljs-comment"># 查看分支情况</span>git <span class="hljs-built_in">log</span> --graph --pretty=oneline --abbrev-commit</code></pre></div><p>保存当前工作环境：</p><p>如果你想在新的分支上操作，但目前的分支工作为完成，可以使用：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 保存当前分支状态</span>git stash<span class="hljs-comment"># 查看保存状态</span>git stash list<span class="hljs-comment"># 恢复不删除</span>git stash apply<span class="hljs-comment"># 恢复删除</span>git stash pop<span class="hljs-comment"># 直接删除</span>git stash drop<span class="hljs-comment"># 为了方便操作，Git 专门提供了一个 cherry-pick 命令，让我们能复制一个特定的提交到当前分支</span>git cherry-pick &lt;分支id&gt;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置地狱：SSM框架整合</title>
    <link href="/2021/10/14/%E9%85%8D%E7%BD%AE%E5%9C%B0%E7%8B%B1%EF%BC%9ASSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/"/>
    <url>/2021/10/14/%E9%85%8D%E7%BD%AE%E5%9C%B0%E7%8B%B1%EF%BC%9ASSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/</url>
    
    <content type="html"><![CDATA[<p>JDK 11 + Spring + Spring MVC + MyBatis + Maven + Tomcat 9.0.44 + MySQL 8.0.25 项目配置文件在 IntelliJ IDEA 下的整合。</p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Maven 严格遵循约定大于配置，不可随意更改 Maven 规定的项目目录结构。</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog5-0.png" alt="Maven + Java Web目录结构"></p><p>如果使用 Maven 的官方模板创建的 Maven Java Web 项目，直接按照配置文件配置即可。</p><p>如果采用在创建普通 Maven 项目后方才导入 Java Web 骨架，Maven导入的Jar包不会被自动添加进项目映射到 Tomcat 的 war 包中，需要手动配置 tomcat war 包的映射。</p><p>本文章采用第二种方式配置 SSM 项目。</p><h1 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h1><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.rootzwy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javaweb-ssm<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.encoding</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-comment">&lt;!-- Junit测试 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!-- MySQL连接器--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 数据库连接池 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mchange<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.5.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!-- Servlet依赖 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!-- JSP依赖 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!-- JSP-jstl标签依赖 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!-- mybatis --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!-- mybatis-spring整合 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!-- Spring Web --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!-- Spring jdbc管理 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!-- Spring aop --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 事务切入 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.9.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!-- Jackson --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.13.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 运行时规定maven需要映射的文件 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><h1 id="springContext-xml"><a href="#springContext-xml" class="headerlink" title="springContext.xml"></a>springContext.xml</h1><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><span class="hljs-tag"><span class="hljs-string">       https://www.springframework.org/schema/beans/spring-beans.xsd</span></span><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/context</span></span><span class="hljs-tag"><span class="hljs-string">       https://www.springframework.org/schema/context/spring-context.xsd</span></span><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/tx</span></span><span class="hljs-tag"><span class="hljs-string">       https://www.springframework.org/schema/tx/spring-tx.xsd</span></span><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/aop</span></span><span class="hljs-tag"><span class="hljs-string">       https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;dispatcherServlet-servlet.xml&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 关联数据库配置文件 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:database.properties&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!--</span><span class="hljs-comment">    配置数据库连接池</span><span class="hljs-comment">    dbcp：半自动，不能自动连接</span><span class="hljs-comment">    c3p0：自动化操作，自动化加载配置文件，并且可以自动设置到对象中</span><span class="hljs-comment">    druid：阿里巴巴数据库连接池</span><span class="hljs-comment">    hikari：Spring Boot 默认连接池</span><span class="hljs-comment">     --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span>        <span class="hljs-comment">&lt;!-- 连接数 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxPoolSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;30&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;minPoolSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10&quot;</span>/&gt;</span>        <span class="hljs-comment">&lt;!-- 关闭连接后不自动提交 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;autoCommitOnClose&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span>        <span class="hljs-comment">&lt;!-- 获取连接超时时间 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;checkoutTimeout&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10000&quot;</span>/&gt;</span>        <span class="hljs-comment">&lt;!-- 连接失败重试次数 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;acquireRetryAttempts&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 配置SqlSessionFactory --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span>        <span class="hljs-comment">&lt;!-- 绑定Mybatis配置文件 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;configLocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 配置mapper接口扫描包，动态实现Dao实现对象注入到Spring中，配置之后，默认id为类首字母小写 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.rootzwy.mapper&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 扫描service --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.rootzwy.service&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 配置声明式事务 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 注入数据源 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 开启事务注解支持 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 设置事务拦截器 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionInterceptor&quot;</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span>            <span class="hljs-comment">&lt;!--</span><span class="hljs-comment">            propagation标签的事务属性详解:</span><span class="hljs-comment">            REQUIRED：支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。</span><span class="hljs-comment">            SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行。</span><span class="hljs-comment">            MANDATORY：支持当前事务，如果当前没有事务，就抛出异常。</span><span class="hljs-comment">            REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起。</span><span class="hljs-comment">            NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</span><span class="hljs-comment">            NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</span><span class="hljs-comment">            NESTED：支持当前事务，如果当前事务存在，则执行一个嵌套事务，如果当前没有事务，就新建一个事务。</span><span class="hljs-comment">             --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 设置切入点 --&gt;</span>    <span class="hljs-comment">&lt;!-- 支持注解设置 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txPointCut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.rootzwy.mapper.*.*(..))&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;transactionInterceptor&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;txPointCut&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><h1 id="dispatcherServlet-servlet-xml"><a href="#dispatcherServlet-servlet-xml" class="headerlink" title="dispatcherServlet-servlet.xml"></a>dispatcherServlet-servlet.xml</h1><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><span class="hljs-tag"><span class="hljs-string">       https://www.springframework.org/schema/beans/spring-beans.xsd</span></span><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/context</span></span><span class="hljs-tag"><span class="hljs-string">       https://www.springframework.org/schema/context/spring-context.xsd</span></span><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/mvc</span></span><span class="hljs-tag"><span class="hljs-string">       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 启动mvc注解支持 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 静态资源过滤 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- controller包扫描 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.rootzwy.controller&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 配置视图解析器 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;internalResourceViewResolver&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><h1 id="mybatis-config-xml"><a href="#mybatis-config-xml" class="headerlink" title="mybatis-config.xml"></a>mybatis-config.xml</h1><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 对包下的类起别名 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.rootzwy.pojo&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>        <span class="hljs-comment">&lt;!--&lt;mapper resource=&quot;mapper/BookMapper.xml&quot;/&gt;--&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre></div><h1 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h1><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4.0&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- Spring DispatcherServlet --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>            <span class="hljs-comment">&lt;!-- 由于servlet要访问Spring容器下的一系列bean，因此需关联两个Context文件 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-comment">&lt;!-- Spring 乱码过滤 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>utf-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>        <span class="hljs-comment">&lt;!-- /*过滤包括jsp在内的所有Servlet --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span>    <span class="hljs-comment">&lt;!-- session生命周期 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">session-config</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 分钟 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">session-timeout</span>&gt;</span>20<span class="hljs-tag">&lt;/<span class="hljs-name">session-timeout</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">session-config</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Java Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Servlet基础知识点回顾（二）</title>
    <link href="/2021/10/04/Servlet%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2021/10/04/Servlet%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本篇文章用于简易回顾Servlet基础知识，并阅读自己之前项目里写过的一些Servlet代码。</p><span id="more"></span><h1 id="Servlet基础知识点回顾（二）"><a href="#Servlet基础知识点回顾（二）" class="headerlink" title="Servlet基础知识点回顾（二）"></a>Servlet基础知识点回顾（二）</h1><p>知识点补充：</p><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1328768897515553">关于Cookie和Session</a></p><p><a href="https://zhuanlan.zhihu.com/p/63061864">简单了解Session、Cookie、Token</a></p><h2 id="Servlet中的Cookie和Session"><a href="#Servlet中的Cookie和Session" class="headerlink" title="Servlet中的Cookie和Session"></a>Servlet中的Cookie和Session</h2><p>一个Web应用，通过Cookie和Session验证用户身份（简要概述）：</p><p>客户端首次访问服务端，服务端登记客户端信息后，给客户端发送Cookies，其中包含Session相关信息，以及一些其它的信息。</p><p>客户端下次访问时，将Cookies发送给客户端，客户端通过解析Cookies来获取客户端信息并进行Session匹配。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>服务端：Servlet通过获取请求中的Cookies、编辑响应中要发送的Cookies，来CRUD Cookies。</p><p>客户端：保存管理服务端发送过来的Cookies。</p><h4 id="Servlet中Cookie的常见操作"><a href="#Servlet中Cookie的常见操作" class="headerlink" title="Servlet中Cookie的常见操作"></a>Servlet中Cookie的常见操作</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// Servlet的Cookie类中的常见字段</span><span class="hljs-comment">// 键值对</span><span class="hljs-keyword">private</span> String name;<span class="hljs-keyword">private</span> String value;<span class="hljs-comment">// 保存时间</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxAge = -<span class="hljs-number">1</span>;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// Servlet对Request中Cookies的基本操作</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CookieDemoServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException,</span><span class="hljs-function">    IOException </span>&#123;        req.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);        resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);        PrintWriter out = resp.getWriter();        <span class="hljs-comment">// 从请求中获取cookies</span>        Cookie[] cookies = req.getCookies();        <span class="hljs-comment">// 判断cookies是否存在</span>        <span class="hljs-keyword">if</span> (cookies != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// 显示req中cookies的信息</span>            <span class="hljs-keyword">for</span> (Cookie cookie : cookies) &#123;                out.write(cookie.getName() + <span class="hljs-string">&quot; &quot;</span> + cookie.getValue() + <span class="hljs-string">&quot;\n&quot;</span>);            &#125;            <span class="hljs-comment">// 查看上次登录时间</span>            <span class="hljs-keyword">for</span> (Cookie cookie : cookies) &#123;                <span class="hljs-keyword">if</span>(cookie.getName().equals(<span class="hljs-string">&quot;latestLoginTime&quot;</span>)) &#123;                    <span class="hljs-keyword">long</span> latestLoginTime = Long.parseLong(cookie.getValue());                    Date date = <span class="hljs-keyword">new</span> Date(latestLoginTime);                    out.write(date.toString());                &#125;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 在该项目中，永远不会进入这个分支，因为最开始访问网站时已经进行了一次Cookie的传输了</span>            out.write(<span class="hljs-string">&quot;第一次进入本服务器&quot;</span>);        &#125;        <span class="hljs-comment">// 更新上次登录时间：新建一个cookie，里面存储访问时间，并放入响应对象</span>        Cookie timeCookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;latestLoginTime&quot;</span>, String.valueOf(System.currentTimeMillis()));        timeCookie.setMaxAge(<span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>); <span class="hljs-comment">// 设置这个cookie的存活时间</span>        resp.addCookie(timeCookie);    &#125;&#125;</code></pre></div><h4 id="Cookie的限制"><a href="#Cookie的限制" class="headerlink" title="Cookie的限制"></a>Cookie的限制</h4><p>一个Cookie只能保存一个信息</p><p>一些浏览器会给Cookies数量设置上限</p><p>Cookie大小一般会限制为4kb</p><p>服务端无法实时地编辑已发送至客户端的Cookies，只能设置Cookies的生命周期来进行删除</p><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>服务端：保存客户端的会话信息，并通过Session来CRUD。</p><p>客户端：通过秘钥，与服务端进行会话的匹配。</p><p>每个Web应用会给每个浏览器创建一个Session对象，只要浏览器没有关闭，Session会一直存在 （多数情况下，服务端也能主动注销Session）</p><p>补充：</p><p><a href="https://www.cnblogs.com/lukelook/p/11095113.html">Session的动态生命周期</a></p><h4 id="Session的使用场景"><a href="#Session的使用场景" class="headerlink" title="Session的使用场景"></a>Session的使用场景</h4><p>保存用户登录信息</p><p>保存购物车信息</p><p>在整个web应用中经常使用的数据，一般都会保留在session中</p><h4 id="Servlet中Session的常见操作"><a href="#Servlet中Session的常见操作" class="headerlink" title="Servlet中Session的常见操作"></a>Servlet中Session的常见操作</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SessionDemoServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        req.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);        resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);        resp.setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);        HttpSession session = req.getSession();        session.setAttribute(<span class="hljs-string">&quot;sessionName&quot;</span>, <span class="hljs-string">&quot;SessionDemoServlet&quot;</span>); <span class="hljs-comment">// get不做演示</span>        String sessionId = session.getId();        <span class="hljs-keyword">if</span> (session.isNew()) &#123;            resp.getWriter().write(<span class="hljs-string">&quot;Session元素创建成功，ID: &quot;</span> + sessionId);        &#125; <span class="hljs-keyword">else</span> &#123;            resp.getWriter().write(<span class="hljs-string">&quot;Session已存在，ID: &quot;</span> + sessionId);        &#125;    &#125;&#125;</code></pre></div><h4 id="XML配置Session"><a href="#XML配置Session" class="headerlink" title="XML配置Session"></a>XML配置Session</h4><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 设置Session的默认失效时间 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">session-config</span>&gt;</span>    <span class="hljs-comment">&lt;!-- </span><span class="hljs-comment">10个时间单位后服务端内的Session失效，时间单位为分钟。</span><span class="hljs-comment">在常见Web应用中，Session注销前会被保存至数据库。</span><span class="hljs-comment">下次获取SessionId时，重新激活这个Session，达到减少服务器负载的效果。</span><span class="hljs-comment">--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">session-timeout</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">session-timeout</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">cookie-config</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 设置sessionId的Cookie在浏览器的保存时间，单位为秒 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">max-age</span>&gt;</span>6000<span class="hljs-tag">&lt;/<span class="hljs-name">max-age</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">cookie-config</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">session-config</span>&gt;</span></code></pre></div><h2 id="关于JSP和Servlet"><a href="#关于JSP和Servlet" class="headerlink" title="关于JSP和Servlet"></a>关于JSP和Servlet</h2><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog4-0.jpg" alt="JSP执行过程"></p><p><strong>JSP的本质就是Servlet-api的一种实现类。</strong></p><p>在Tomcat中，JSP被转换称为一个Servlet实现类，并且进行了编译之后才转换为Web容器能处理的Servlet对象。</p><p><strong>由此可见，Servlet是Java Web编程中实现动态网页的一种重要手段，是Java各种Web的框架的底层核心。</strong></p><h2 id="关于MVC架构和Servlet"><a href="#关于MVC架构和Servlet" class="headerlink" title="关于MVC架构和Servlet"></a>关于MVC架构和Servlet</h2><p>一般来说，Servlet处于控制层（Controller），专注于接收用户请求、发送响应给用户、重定向或转发视图层中的视图等一系列控制操作，很少涉及业务逻辑代码，虽然在原则上说，Servlet可以完成Web应用的几乎所有功能，但为了代码解耦，让架构中的每个层级分工明确，Servlet一般仅作用于Controller层。</p><h2 id="Servlet过滤器"><a href="#Servlet过滤器" class="headerlink" title="Servlet过滤器"></a>Servlet过滤器</h2><p>用来过滤从Web容器（客户端到Web容器再到Servlet）中获得的数据（例如HttpServletRequest、HttpServletRequest），比如过滤无用信息、统一字符编码、过滤用户等级、登录验证等操作。</p><h3 id="过滤器实例：统一字符编码"><a href="#过滤器实例：统一字符编码" class="headerlink" title="过滤器实例：统一字符编码"></a>过滤器实例：统一字符编码</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 注解配置过滤器的方式</span><span class="hljs-meta">@WebFilter(filterName = &quot;EncodingFilter&quot;, urlPatterns = &quot;/filterTest/*&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EncodingFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;        <span class="hljs-comment">// 在web服务器开始运行时，过滤器就会生成</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        servletRequest.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);        servletResponse.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);        servletResponse.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);        System.out.println(<span class="hljs-string">&quot;过滤器生效前&quot;</span>);        <span class="hljs-comment">// 放行数据，并继续执行可能存在的下一个过滤器</span>        filterChain.doFilter(servletRequest, servletResponse);        System.out.println(<span class="hljs-string">&quot;过滤器已生效&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//web服务器关闭后销毁过滤器</span>    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 使用xml配置的方式 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CodeFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>com.rootzwy.controller.EncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CodeFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/filterTest/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span></code></pre></div><h2 id="Servlet监听器"><a href="#Servlet监听器" class="headerlink" title="Servlet监听器"></a>Servlet监听器</h2><p>顾名思义，监听Servlet中的一系列操作，如Session、ServletContext等，与过滤器不同，监听器一开始就定义了一系列元素的监听器接口，继承自<code>EventListener</code>接口</p><p>监听器实例：监听Session创建</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.servlet.*;<span class="hljs-keyword">import</span> javax.servlet.http.*;<span class="hljs-keyword">import</span> javax.servlet.annotation.*;<span class="hljs-comment">// 使用注解配置监听器的方式</span><span class="hljs-meta">@WebListener()</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FilterTestListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServletContextListener</span>, <span class="hljs-title">HttpSessionListener</span>, <span class="hljs-title">HttpSessionAttributeListener</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FilterTestListener</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextInitialized</span><span class="hljs-params">(ServletContextEvent sce)</span> </span>&#123;        <span class="hljs-comment">/* This method is called when the servlet context is initialized(when the Web application is deployed). */</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextDestroyed</span><span class="hljs-params">(ServletContextEvent sce)</span> </span>&#123;        <span class="hljs-comment">/* This method is called when the servlet Context is undeployed or Application Server shuts down. */</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sessionCreated</span><span class="hljs-params">(HttpSessionEvent se)</span> </span>&#123;        <span class="hljs-comment">/* Session is created. */</span>        HttpSession session = se.getSession();        System.out.println(session.getAttribute(<span class="hljs-string">&quot;&quot;</span>));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sessionDestroyed</span><span class="hljs-params">(HttpSessionEvent se)</span> </span>&#123;        <span class="hljs-comment">/* Session is destroyed. */</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attributeAdded</span><span class="hljs-params">(HttpSessionBindingEvent sbe)</span> </span>&#123;        <span class="hljs-comment">/* This method is called when an attribute is added to a session. */</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attributeRemoved</span><span class="hljs-params">(HttpSessionBindingEvent sbe)</span> </span>&#123;        <span class="hljs-comment">/* This method is called when an attribute is removed from a session. */</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attributeReplaced</span><span class="hljs-params">(HttpSessionBindingEvent sbe)</span> </span>&#123;        <span class="hljs-comment">/* This method is called when an attribute is replaced in a session. */</span>    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 在xml中配置监听器的方式 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>com.rootzwy.controller.FilterTestListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Java Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Servlet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Servlet基础知识点回顾（一）</title>
    <link href="/2021/10/04/Servlet%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2021/10/04/Servlet%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本篇文章用于简易回顾Servlet基础知识，并阅读自己之前项目里写过的一些Servlet代码。</p><span id="more"></span><h1 id="Servlet基础知识点回顾（一）"><a href="#Servlet基础知识点回顾（一）" class="headerlink" title="Servlet基础知识点回顾（一）"></a>Servlet基础知识点回顾（一）</h1><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog3-0.jpg" alt="Servlet生命周期"></p><h2 id="什么是Servlet？"><a href="#什么是Servlet？" class="headerlink" title="什么是Servlet？"></a>什么是Servlet？</h2><p>Servlet是Sun公司专门用于开发动态Web网页的一门技术，Servlet API中封存了大量的接口和一些实现类来帮助程序员处理web请求和响应。Servlet规定了一系列接口规范，是软件项目工程化的重要体现。</p><p>Servlet需要在web.xml中配置路径名和映射，将Servlet映射到Web容器中，并指定Servlet需要处理的路径，Web容器才能找到这个Servlet并进行处理。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.rootzwy.servlet.HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre></div><p>第一个Servlet程序：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        PrintWriter writer = resp.getWriter();        writer.println(<span class="hljs-string">&quot;Hello, Servlet!&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;    &#125;</code></pre></div><h2 id="Servlet基本原理"><a href="#Servlet基本原理" class="headerlink" title="Servlet基本原理"></a>Servlet基本原理</h2><p>以HTTP协议为例，浏览器端发送HTTP请求到Web容器，Web容器接收到这个请求，并将其中诸如请求头、请求体等信息封装为<code>HttpServletRequest</code>对象，同时也创建一个<code>HttpServletResponse</code>对象。在浏览器端首次访问时，创建特定的<code>Servlet</code>对象，这个对象用于处理收到的请求对象，并且编辑响应对象，再将响应对象回传给Web容器，Web容器将响应对象读取转换后发送给浏览器端。</p><h2 id="Servlet映射问题"><a href="#Servlet映射问题" class="headerlink" title="Servlet映射问题"></a>Servlet映射问题</h2><p>一个Servlet可以指定一个映射路径。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.rootzwy.servlet.HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre></div><p>一个Servlet可以指定多个映射路径。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.rootzwy.servlet.HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello1<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello2<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre></div><p>一个Servlet可以指定通用路径。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.rootzwy.servlet.HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><span class="hljs-comment">&lt;!-- 或者指定以特定后缀结尾的路径 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 例如：localhost:8080/asdf/hello.zwy --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.rootzwy<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre></div><p>一个Servlet可以覆盖<code>index</code>。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.rootzwy.servlet.HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><span class="hljs-comment">&lt;!-- 对于具体的路径，Servlet会优先走具体路径，比如 /hello --&gt;</span></code></pre></div><h2 id="Servlet中的常用对象和方法"><a href="#Servlet中的常用对象和方法" class="headerlink" title="Servlet中的常用对象和方法"></a>Servlet中的常用对象和方法</h2><h3 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a>HttpServlet</h3><p><code>HttpServlet</code>是一个抽象类，继承自<code>GenericServlet</code>类，实现了<code>Servlet</code>接口，封装了一些处理Web请求响应和Servlet管理的方法，例如经典的<code>doGet()</code>、<code>doPost()</code>、<code>getServletContext()</code>等。程序员通过继承此类来重写对应方法，经过<code>service()</code>方法来处理请求和响应。</p><h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><p>Web容器启动时，Web容器为每一个Web程序都创建一个<code>ServletContext</code>对象，来充当Web程序和Web容器的上下文，每个<code>Servlet</code>对象代表一个Web程序。以下列出<code>ServletContext</code>的一些常见基本功能。</p><p>Servlet间共享数据：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// In Servlet1</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException</span><span class="hljs-function"></span>&#123;    ServletContext context = <span class="hljs-keyword">this</span>.getServletContext();    String userName = <span class="hljs-string">&quot;zwy&quot;</span>;    <span class="hljs-comment">// 将userName存放进ServletContext中，将在Servlet2中访问这个属性</span>    context.setAttribute(<span class="hljs-string">&quot;userName&quot;</span>, userName);&#125;<span class="hljs-comment">// In Servlet2</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;    ServletContext context = <span class="hljs-keyword">this</span>.getServletContext();    <span class="hljs-comment">// 从ServletContext获取userName</span>    String userName = (String) context.getAttribute(<span class="hljs-string">&quot;userName&quot;</span>);    PrintWriter writer = resp.getWriter();    resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);    resp.setContentType(<span class="hljs-string">&quot;text/html&quot;</span>);    <span class="hljs-comment">// 输出userName</span>    writer.println(<span class="hljs-string">&quot;Hello, &quot;</span> + userName);&#125;</code></pre></div><p>获取web.xml相应元素：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- In web.xml --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">contxt-param</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>mysqlUrl<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>jdbc:mysql://localhors:3306<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">contxt-param</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// In Servlet</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;    ServletContext context = <span class="hljs-keyword">this</span>.getServletContect();    String url = context.getInitParameter(<span class="hljs-string">&quot;mysqlUrl&quot;</span>);    resp.getwriter().println(url);&#125;</code></pre></div><p> 读取资源文件</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// In Servlet</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;    <span class="hljs-comment">// 此处是编译之后资源文件的路径</span>    InputStream is = <span class="hljs-keyword">this</span>.getServletContext().getResourceAsStream(<span class="hljs-string">&quot;/WEB-INF/classes/test.properties&quot;</span>);    Properties properties = <span class="hljs-keyword">new</span> Properties();    properties.load(is);    String name = properties.getProperty(<span class="hljs-string">&quot;username&quot;</span>);    String pwd = properties.getProperty(<span class="hljs-string">&quot;password&quot;</span>);    PrintWriter writer = resp.getWriter();    resp.setContentType(<span class="hljs-string">&quot;text/html&quot;</span>);   resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);    writer.println(<span class="hljs-string">&quot;User: &quot;</span> + name);    writer.println(<span class="hljs-string">&quot;Password: &quot;</span> + pwd);&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># In properties</span><span class="hljs-attr">username</span>=<span class="hljs-string">root</span><span class="hljs-attr">password</span>=<span class="hljs-string">123456</span></code></pre></div><h3 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h3><p><code>HttpServletResponse</code>是一个接口，继承了<code>ServletResponse</code>。Web容器在接收到请求时，会针对这个请求，默认创建一个实现这个响应接口的对象，用于封装响应，让程序员通过代码去操作响应信息。</p><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function">PrintWriter <span class="hljs-title">getWriter</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<span class="hljs-function">ServletOutputStream <span class="hljs-title">getOutputStream</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setCharacterEncoding</span><span class="hljs-params">(String var1)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setContentLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span> var1)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setContentType</span><span class="hljs-params">(String var1)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setDateHeader</span><span class="hljs-params">(String var1, <span class="hljs-keyword">long</span> var2)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addDateHeader</span><span class="hljs-params">(String var1, <span class="hljs-keyword">long</span> var2)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setHeader</span><span class="hljs-params">(String var1, String var2)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addHeader</span><span class="hljs-params">(String var1, String var2)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setIntHeader</span><span class="hljs-params">(String var1, <span class="hljs-keyword">int</span> var2)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addIntHeader</span><span class="hljs-params">(String var1, <span class="hljs-keyword">int</span> var2)</span></span>;<span class="hljs-comment">// ......</span></code></pre></div><h4 id="常见应用"><a href="#常见应用" class="headerlink" title="常见应用"></a>常见应用</h4><h5 id="向浏览器输出文本或其它数据。"><a href="#向浏览器输出文本或其它数据。" class="headerlink" title="向浏览器输出文本或其它数据。"></a>向浏览器输出文本或其它数据。</h5><p>例如下载文件：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;    <span class="hljs-comment">// 获取下载文件的路径</span>    ServletContext context = <span class="hljs-keyword">this</span>.getServletContext();    String path = context.getRealPath(<span class="hljs-string">&quot;/WEB-INF/classes/txt/yinsha.txt&quot;</span>);    String fileName = path.substring(path.lastIndexOf(<span class="hljs-string">&quot;\\&quot;</span>) + <span class="hljs-number">1</span>);    System.out.println(<span class="hljs-string">&quot;输出文件的名称： &quot;</span> + fileName);    <span class="hljs-comment">// 设置浏览器下载头和编码格式</span>    resp.setHeader(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment;filename=&quot;</span>            + URLEncoder.encode(fileName, StandardCharsets.UTF_8));<span class="hljs-comment">// resp.setContentType(&quot;text/html&quot;); // 若指定当前页面为html，则下载的文件都是html文件</span>    resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);    <span class="hljs-comment">// 获取文件流</span>    FileInputStream in = <span class="hljs-keyword">new</span> FileInputStream(path);    <span class="hljs-comment">// 创建缓冲区</span>    <span class="hljs-keyword">int</span> len;    <span class="hljs-keyword">byte</span>[] fileBuffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];    <span class="hljs-comment">// 获取输出流</span>    ServletOutputStream out = resp.getOutputStream();    <span class="hljs-comment">// 输出流从Buffer获取文件流</span>    <span class="hljs-keyword">while</span> ((len = in.read(fileBuffer)) != -<span class="hljs-number">1</span>) &#123;        out.write(fileBuffer, <span class="hljs-number">0</span>, len);    &#125;    out.close();    in.close();&#125;</code></pre></div><p>实现简易的动态验证码：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityCodeImgServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        <span class="hljs-comment">// 网页定时刷新</span>        resp.setHeader(<span class="hljs-string">&quot;refresh&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>);        <span class="hljs-comment">// 在缓存中创建一个图片</span>        BufferedImage image = <span class="hljs-keyword">new</span> BufferedImage(<span class="hljs-number">80</span>, <span class="hljs-number">20</span>, BufferedImage.TYPE_INT_RGB);        <span class="hljs-comment">// 得到图片的画笔，并写入验证码</span>        Graphics2D imgGraphics = (Graphics2D) image.getGraphics();<span class="hljs-comment">//        Graphics2D imgGraphics = image.createGraphics();</span>        imgGraphics.setColor(Color.WHITE);        imgGraphics.fillRect(<span class="hljs-number">0</span> ,<span class="hljs-number">0</span>, <span class="hljs-number">80</span>, <span class="hljs-number">20</span>);        imgGraphics.setColor(Color.BLACK);        imgGraphics.setFont(<span class="hljs-keyword">new</span> Font(<span class="hljs-keyword">null</span>, Font.BOLD, <span class="hljs-number">20</span>));        imgGraphics.drawString(randomSecurityCodeString(), <span class="hljs-number">0</span>, <span class="hljs-number">20</span>);        <span class="hljs-comment">// 告诉浏览器响应页面的格式</span>        resp.setContentType(<span class="hljs-string">&quot;image/png&quot;</span>);        <span class="hljs-comment">// Expires表示存在时间，允许客户端在这个时间之前不去检查（发请求）</span>        resp.setDateHeader(<span class="hljs-string">&quot;expires&quot;</span>, -<span class="hljs-number">1</span>);        <span class="hljs-comment">// Cache-control 用于控制HTTP缓存（在HTTP/1.0中可能部分没实现，仅仅实现了 Pragma: no-cache）</span>        resp.setHeader(<span class="hljs-string">&quot;Cache-Control&quot;</span>, <span class="hljs-string">&quot;no-cache&quot;</span>);        resp.setHeader(<span class="hljs-string">&quot;Pragma&quot;</span>, <span class="hljs-string">&quot;no-cache&quot;</span>);        <span class="hljs-comment">// 把图片写给浏览器(formatName必须是可以使用的图片后缀名)</span>        ImageIO.write(image, <span class="hljs-string">&quot;png&quot;</span>, resp.getOutputStream());    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">randomSecurityCodeString</span><span class="hljs-params">()</span> </span>&#123;        Random random = <span class="hljs-keyword">new</span> Random();        <span class="hljs-comment">// 设置编码为7位</span>        <span class="hljs-keyword">int</span> digit = <span class="hljs-number">7</span>;        <span class="hljs-comment">// 生成编码字符串</span>        <span class="hljs-keyword">int</span> limit = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; digit; i++) &#123;            limit *= <span class="hljs-number">10</span>;        &#125;        String randomNum = <span class="hljs-string">&quot;&quot;</span> + random.nextInt(limit);                <span class="hljs-comment">// 字符串前置补0</span>        StringBuffer stringBuffer = <span class="hljs-keyword">new</span> StringBuffer();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; digit - randomNum.length(); i++) &#123;            stringBuffer.append(<span class="hljs-string">&quot;0&quot;</span>);        &#125;        stringBuffer.append(randomNum);        <span class="hljs-keyword">return</span> stringBuffer.toString();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre></div><h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sendRedirect</span><span class="hljs-params">(String var1)</span> <span class="hljs-keyword">throws</span> IOException</span>; <span class="hljs-comment">// var1是web路径名，如：hello（没有web主路径的&quot;/&quot;）</span></code></pre></div><p>登录重定向和请求转发流程：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;    <span class="hljs-comment">// 在一个Servlet中重定向到负责登录的jsp或Servlet</span>    resp.sendRedirect(<span class="hljs-string">&quot;login.jsp&quot;</span>);&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs jsp">&lt;%-- 在此页面（login.jsp）获取用户名信息，然后POST到action下的Servlet页面--%&gt;&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/waiting&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;    用户名：    &lt;label&gt;        &lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;username&quot;</span>&gt;    &lt;/label&gt; &lt;br&gt;    密 码：    &lt;label&gt;        &lt;input type=<span class="hljs-string">&quot;password&quot;</span> name=<span class="hljs-string">&quot;password&quot;</span>&gt;    &lt;/label&gt; &lt;br&gt;    识别码：    &lt;label&gt;        &lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;uid&quot;</span>&gt;    &lt;/label&gt; &lt;br&gt;    &lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 在此Servlet中可以获取用户名密码，并进行操作，登录成功后请求转发或重定向到WelcomeServlet</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">loginWaitingServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        String uid = req.getParameter(<span class="hljs-string">&quot;uid&quot;</span>);        String uname = req.getParameter(<span class="hljs-string">&quot;username&quot;</span>);        <span class="hljs-keyword">if</span> (!uid.equals(<span class="hljs-string">&quot;root&quot;</span>)) &#123;            resp.sendRedirect(<span class="hljs-string">&quot;pwdError&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//            resp.sendRedirect(&quot;welcome&quot;);</span>            <span class="hljs-comment">// 请求转发传递数据</span>            RequestDispatcher dispatcher = req.getRequestDispatcher(<span class="hljs-string">&quot;welcome&quot;</span>);            dispatcher.forward(req, resp);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre></div><h3 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h3><p><code>HttpServletRequest</code>是一个接口，继承了<code>ServletRequest</code>。Web容器在接收到通过HTTP协议发送过来的请求时，会针对这个请求，默认创建一个实现这个请求接口的对象，用于封装请求的所有信息，让程序员通过代码去操作请求信息。</p><h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 几乎所有...</span></code></pre></div><h4 id="常见应用-1"><a href="#常见应用-1" class="headerlink" title="常见应用"></a>常见应用</h4><h5 id="获取前端参数"><a href="#获取前端参数" class="headerlink" title="获取前端参数"></a>获取前端参数</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 用于获取普通的前端参数</span><span class="hljs-function">String <span class="hljs-title">getParameter</span><span class="hljs-params">(String var1)</span></span>;<span class="hljs-comment">// 用于获取有多个值的前端参数</span> String[] getParameterValues(String var1);</code></pre></div><h5 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function">RequestDispatcher <span class="hljs-title">getRequestDispatcher</span><span class="hljs-params">(String var1)</span></span>;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Java Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Servlet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java虚拟机运行时数据区域概述</title>
    <link href="/2021/09/05/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%E6%A6%82%E8%BF%B0/"/>
    <url>/2021/09/05/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>Java虚拟机运行时，内存布局中各个数据区域的简要概述。</p><span id="more"></span><h1 id="Java虚拟机运行时数据区域"><a href="#Java虚拟机运行时数据区域" class="headerlink" title="Java虚拟机运行时数据区域"></a>Java虚拟机运行时数据区域</h1><p>JVM 内存布局其一</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog2-0.png" alt="JVM内存布局其一"></p><p>JVM内存布局其二</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog2-1.png" alt="JVM内存布局其二"></p><p>《深入理解Java虚拟机》JVM内存布局</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog2-2.png" alt="书中JVM内存布局"></p><h2 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h2><p>程序计数器是一块比较小的内存空间，它可以看做是当前线程所执行字节码的行号显示器。在Java虚拟机的概念模型里，<strong>字节码解释器工作时就是通过改变这个计数器的值来选取下一条执行的字节码指令的</strong>，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>在Java虚拟机中，多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，因此每个时刻只会执行一个线程中的指令，因此，为了线程切换后能恢复到正确的执行位置，<strong>每个线程都有一个独立的程序计数器</strong>。</p><p><strong>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是<code>Native</code>方法，这个计数器值则应为<code>Undefined</code>。</strong>此内存区域是唯 一一个在《Java虚拟机规范》中没有规定任何<code>OutOfMemoryError</code>情况的区域。</p><h2 id="Java虚拟机栈（Java-Visual-Machine-Stack）"><a href="#Java虚拟机栈（Java-Visual-Machine-Stack）" class="headerlink" title="Java虚拟机栈（Java Visual Machine Stack）"></a>Java虚拟机栈（Java Visual Machine Stack）</h2><p><strong>Java虚拟机栈和程序计数器一样是线程私有的，它的生命周期和线程相同。</strong>虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信 息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><p>局部变量表存放了编译期可知的各种Java虚拟机基本数据类型、对象引用（<code>reference</code>类型，它并不等同于对象本身，可能是一个指向对象起始 地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和<code>returnAddress</code> 类型（指向了一条字节码指令的地址）。</p><p><strong>这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示，其中64位长度的<code>long</code>和 <code>double</code>类型的数据会占用两个变量槽，其余的数据类型只占用一个。</strong>局部变量表所需的内存空间在编译期间完成分配，<strong>当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的</strong>，在方法运行期间不会改变局部变量表的大小。请注意，这里说的“大小”是指变量槽的数量， <strong>虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一个变量槽，这是完全由具体的虚拟机实现自行决定的事情。</strong> </p><p>在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出<code>StackOverflowError</code>异常；如果Java虚拟机栈容量可以动态扩展（HotSpot虚拟机的栈容量是不可以动态拓展的），当栈扩 展时无法申请到足够的内存会抛出<code>OutOfMemoryError</code>异常。</p><h2 id="本地方法栈（Native-Method-Stacks）"><a href="#本地方法栈（Native-Method-Stacks）" class="headerlink" title="本地方法栈（Native Method Stacks）"></a>本地方法栈（Native Method Stacks）</h2><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别只是<strong>虚拟机栈为虚拟机执行Java方法（即字节码）服务，而本地方法栈则是为虚拟机使用到的<code>Native</code> 方法服务</strong>。</p><p>与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失 败时分别抛出<code>StackOverflowError</code>和<code>OutOfMemoryError</code>异常。</p><h2 id="Java堆（Java-Heap）"><a href="#Java堆（Java-Heap）" class="headerlink" title="Java堆（Java Heap）"></a>Java堆（Java Heap）</h2><p>Java堆是虚拟机所管理的内存中最大的一块。<strong>Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例</strong>，Java 世界里<strong>几乎</strong>所有的对象实例都在这里分配内存。在《Java虚拟机规范》中对Java堆的描述是：“所有的对象实例以及数组都应当在堆上分配”，而这里的“几乎”是指从实现角度来看，随着Java语言的发展，Java对象实例都分配在堆上也渐渐变得不是那么绝对了。</p><p><strong>Java堆是垃圾收集器管理的内存区域</strong>，一些资料中它也被称作<strong>GC堆</strong>（Garbage Collected Heap）。从回收内存的角度看，由于<strong>现代垃圾收集器大部分都是基于分代收集理论设计的</strong>，因此Java堆常常会被划分为许多区域，比如<strong>经典分代</strong>（新生代、老年代），但这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格而已，而非某个Java虚拟机具体实现的固有内存布局，更不是《Java虚拟机规范》里对Java堆的进一步细致划分。到了今天，垃圾收集器技术与十年前已不可同日而语，HotSpot里面也出现了不采用分代设计的新垃圾收集器。</p><p>如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区 （Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。但无论是哪个区域，存储的都只能是对象的实例，将Java堆细分的目的只是为了更好地回收内存，或者更快地分配内存。</p><p>根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的，这点就像用磁盘空间去存储文件一样，并不要求每个文件都连续存放。但对于<strong>大对象（典型的如数组对象）</strong>，多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。</p><p>Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数设定）。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出<code>OutOfMemoryError</code>异常。</p><h2 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h2><p>方法区与Java堆一样，是各个线程共享的内存区域，它<strong>用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。虽然<strong>《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分（比如字符串常量池，逻辑上属于方法区，但实际放置于Java堆）</strong>，但是它却有一个别名叫作“非堆”（Non-Heap），目的是与Java堆区分开来。</p><p>注意：</p><p>在JDK1.8之后，方法区的实现方法从永久代彻底替换为元空间（Meta-space）。因为在永久代中，容易出现性能问题和内存溢出，因为永久代有<code>-XX: MaxPermSize</code>的上限，即便不设置也有默认大小。</p><p>在JDK1.7之后，方法区中的字符串常量池、静态变量<strong>等</strong>移至Java堆放置。</p><p>《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的确是比较少出现的，这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收效果比较难令人满意，尤 其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。</p><p>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出<code> OutOfMemoryError</code>异常。</p><h3 id="JDK-8后，永久代去哪了？"><a href="#JDK-8后，永久代去哪了？" class="headerlink" title="JDK 8后，永久代去哪了？"></a>JDK 8后，永久代去哪了？</h3><p><a href="https://www.zhihu.com/question/39990490/answer/84155229">JDK8之后，永久代去哪了？</a></p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog2-3.png" alt="永久代去哪了？"></p><p><a href="https://www.zhihu.com/question/438698030/answer/1670533755">拓展知识：虚拟机之于本地内存</a></p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog2-4.jpg" alt="虚拟机之于本地内存"></p><p><a href="https://zhuanlan.zhihu.com/p/111809384">元空间和永久代的详细区别</a></p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog2-5.jpg" alt="内存划分对比"></p><h3 id="运行时常量池（Runtime-Constant-Pool）"><a href="#运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="运行时常量池（Runtime Constant Pool）"></a>运行时常量池（Runtime Constant Pool）</h3><p>运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p> Java虚拟机对于Class文件每一部分（自然也包括常量池）的格式都有严格规定，如每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、加载和执行，但对于运行时常量池， 《Java虚拟机规范》并没有做任何细节的要求，不同提供商实现的虚拟机可以按照自己的需要来实现 这个内存区域，不过一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中。 </p><p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是<code>String</code>类的 <code>intern()</code>方法。 既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存 时会抛出<code>OutOfMemoryError</code>异常。</p><h2 id="直接内存（Direct-Memory）"><a href="#直接内存（Direct-Memory）" class="headerlink" title="直接内存（Direct Memory）"></a>直接内存（Direct Memory）</h2><p>直接内存并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致<code>OutOfMemoryError</code>异常出现，因此放在此处讨论。 </p><p>在JDK1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区 （Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的 <code>DirectByteBuffer</code>对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。 显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务 器管理员配置虚拟机参数时，会根据实际内存去设置<code>-Xmx</code>等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现 <code>OutOfMemoryError</code>异常。</p>]]></content>
    
    
    <categories>
      
      <category>Java虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java虚拟机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法基础知识回顾</title>
    <link href="/2021/04/14/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"/>
    <url>/2021/04/14/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/</url>
    
    <content type="html"><![CDATA[<p>回顾学习算法时所必须了解的一些基本知识。</p><span id="more"></span><p>本篇文章用于简要梳理在算法中的一些需要了解的基本知识点。</p><h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><p><strong>To measure is to know. If you can not measure it, you can not improve it.</strong></p><p>本部分通过引入理想、统一、分层次的尺度标准，来衡量算法的性能。</p><h2 id="大O记号"><a href="#大O记号" class="headerlink" title="大O记号"></a>大O记号</h2><p>大O记号通过划分上界，来悲观地衡量一个算法的性能。</p><p>注意：O(f(n)) 并不一定会完全处于 T(n) 之上，但可以通过如图中对 f(n) 乘以常系数 c 来做到拉高上界的作用。</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog1-0.png" alt="大O记号"></p><h2 id="其它记号"><a href="#其它记号" class="headerlink" title="其它记号"></a>其它记号</h2><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog1-1.png" alt="其他记号"></p><h2 id="大O记号的刻度"><a href="#大O记号的刻度" class="headerlink" title="大O记号的刻度"></a>大O记号的刻度</h2><p><strong>常数复杂度 O( 1 )</strong></p><p>算法不含随输入规模变换的转向（循环、调用、递归等），且顺序执行，则说这个算法的复杂度为 O(1)。</p><p><strong>对数复杂度 O( log^c(n) )</strong></p><p>在此种情况中，对数的底数常常会被忽略，因为往往可以通过数学变换来改变对数的底数。</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog1-2.png" alt="底数变换"></p><p>这类算法非常高效，复杂度无限接近于常数。</p><p><strong>多项式复杂度 O( n^c )</strong></p><p>此种复杂度由于影响因素往往取决于最高次幂项，因此较低次幂的项往往忽略不计。</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog1-3.png" alt="多项式复杂度"></p><p>其中，当幂次 c == 1 时，表示算法的时间复杂度与 n 线性相关，因此称 O(n) 为线性复杂度。</p><p><strong>指数复杂度 O( 2^n )</strong></p><p>当一个算法的计算成本按指数增长时，往往我们认为此种算法为问题的难解。</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog1-4.png" alt="指数复杂度"></p><p>我们可以从下图中观察各个复杂度的增长速度：</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog1-5.png" alt="复杂度的增长速度"></p><h2 id="级数"><a href="#级数" class="headerlink" title="级数"></a>级数</h2><p>以下图片总结了一些常见的级数。</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog1-6.png" alt="级数1"></p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog1-7.png" alt="级数2"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Hexo博客框架搭建静态博客</title>
    <link href="/2021/04/06/%E4%BD%BF%E7%94%A8Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/04/06/%E4%BD%BF%E7%94%A8Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>本篇文章用于记录如何在 Windows 中使用 Hexo 博客框架搭建个人静态博客。</p><span id="more"></span><p>在该篇文章中，您将会看到：静态博客搭建相关技术简介、博客搭建流程、使用主题来美化博客，最后将博客发布至 GitHub。</p><p>一些碎语：</p><p>在不同的操作系统中搭建静态博客的方法大同小异，因此此篇文章步骤也基本适用于其它操作系统。</p><p>博客搭建过程中难免会遇到不同问题，您可能和本人一样有着轻微的强迫症，不容许搭建过程中产生半点冗余内容，不用担心，此博客的所有内容都汇集在一个文件夹中，若搭建过程中遇到难以解决的问题，直接干掉未搭建完成的博客文件夹即可，而且如果完全按照此文章进行博客创建，途中产生的警告可完全忽略。</p><p>个人在两种操作系统中都搭建过静态博客，由于文件系统和权限等原因，在 Linux 中的安装流程更为顺畅，但由于Windows环境下能更加方便地编写发布博客，因此最后选择了 Windows。</p><p>此后可能会写将博客部署到云服务器的操作流程，但这是后话了，此时先专注于本篇文章。</p><h1 id="相关内容简介"><a href="#相关内容简介" class="headerlink" title="相关内容简介"></a>相关内容简介</h1><p>对相关技术了解较深或不感兴趣可以跳过该部分。</p><p>该部分将会简要介绍搭建静态博客时所涉及到的部分术语和相关技术，仅做简要介绍，具体请自行进行搜索。</p><p><strong>动态博客和静态博客</strong></p><p>此处的两种术语表示了两种不同的博客搭建形式，基本类似于静态网站和动态网站的区别。</p><p>动态博客，是指具有前端和后端的动态博客网站，类似于 CSDN、博客园等博客论坛，可以实现网站代码编写和功能使用的分离，其灵活性、易用性和功能性相较于静态博客都比较高。</p><p>静态博客，是指使用纯前端的形式搭建的静态博客网站，由于没有后台管理，因此对静态博客的每一个操作都与代码耦合，更难使用且功能更少，并且缺少动态交互。</p><p><strong>Hexo</strong></p><p>Hexo 是一个快速、简洁且高效的静态博客框架。该框架基于Node.js运行环境，能够帮助我们快速地搭建静态博客。</p><p><strong>Node.js</strong></p><p>“Node.js is a JavaScript runtime built on Chrome’s V8 JavaScript Engine.”</p><p>Node.js 不是一门编程语言，而是基于Chrome V8引擎的JavaScript语言运行环境，是一种宿主环境，类似于浏览器。</p><p><strong>GitHub</strong></p><p>GitHub 是一个开源的软件项目托管平台，由于其使用 Git 作为版本库格式进行托管，因此被命名为 GitHub。</p><p><strong>Git</strong></p><p>Git 是目前世界上较为先进的分布式版本控制系统，通过 Git，您可以方便地对项目的改动进行记录，还可以与其他人进行协作编辑，从而实现对项目的版本进行管理。</p><h1 id="静态博客搭建流程（Windows）"><a href="#静态博客搭建流程（Windows）" class="headerlink" title="静态博客搭建流程（Windows）"></a>静态博客搭建流程（Windows）</h1><p>该部分将展示 Windows 10 系统下静态博客的搭建流程，其中省略了一些较为简单的操作步骤。</p><p><strong>强烈建议在管理员模式下的命令行执行该流程。</strong></p><h2 id="1-下载-Node-js-和-Git"><a href="#1-下载-Node-js-和-Git" class="headerlink" title="1. 下载 Node.js 和 Git"></a>1. 下载 Node.js 和 Git</h2><p>个人建议从官方网站下载最新版本的Node.js和Git。</p><p><a href="https://nodejs.org/">Node.js 官方网站</a></p><p><a href="https://git-scm.com/">Git 官方网站</a></p><p>关于 Node.js 和 Git 的详细安装和环境配置流程，由于不属于本篇的主要内容，且流程对后续步骤影响不大，故不再列出，您可自行进行搜索，或直接采用默认的安装选项安装即可，必须确保两者被成功安装。</p><p><strong>检查 Node.js 和 Git 是否安装以及配置成功</strong></p><p>打开 Windows 的命令行工具，输入：</p><div class="code-wrapper"><pre><code class="hljs bash">$ node -v</code></pre></div><p>若弹出 Node.js 版本信息，说明 Node.js 安装成功。</p><p>输入：</p><div class="code-wrapper"><pre><code class="hljs bash">$ git</code></pre></div><p>若弹出 Git 的命令使用说明，说明 Git 安装成功。</p><h2 id="2-通过-Node-js-的-npm-安装-Hexo"><a href="#2-通过-Node-js-的-npm-安装-Hexo" class="headerlink" title="2. 通过 Node.js 的 npm 安装 Hexo"></a>2. 通过 Node.js 的 npm 安装 Hexo</h2><p>完成此部分，您就基本准备好了博客搭建所需要的工具。</p><p><strong>npm</strong></p><p>Node.js 的包管理器，允许客户从npm服务器中下载第三方的包到本地使用。在 Node.js 安装时自带。</p><h3 id="2-1-安装-cnpm（可选）"><a href="#2-1-安装-cnpm（可选）" class="headerlink" title="2.1. 安装 cnpm（可选）"></a>2.1. 安装 cnpm（可选）</h3><p>由于 npm 的镜像位于国外，因此下载速度较慢，cnpm 是中国的 npm 镜像客户端，此处将 cnpm 的镜像源指向淘宝的镜像源，后续的 npm 命令可以使用 cnpm 代替，npm 命令的详细含义可自行百度搜索，此处不再列出。</p><p>若您对所处的网络环境很自信，或者有 VPN，觉得没有这个必要，可跳过此步骤。</p><p>进入 Windows 命令行工具，输入：</p><div class="code-wrapper"><pre><code class="hljs bash">$ npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre></div><p>此后，输入：</p><div class="code-wrapper"><pre><code class="hljs bash">$ cnpm</code></pre></div><p>若弹出 cnpm 的命令使用说明，说明 cnpm 安装成功。</p><p>此处 cnpm 被安装在 npm 的默认路径，您可以通过修改此路径来统一管理包。</p><h3 id="2-2-安装Hexo"><a href="#2-2-安装Hexo" class="headerlink" title="2.2. 安装Hexo"></a>2.2. 安装Hexo</h3><p><strong>若您安装了 cnpm，将下面的 npm 改为 cnpm 即可。</strong></p><p>打开 Windows 命令行，输入：</p><div class="code-wrapper"><pre><code class="hljs bash">$ npm install -g hexo-cli</code></pre></div><p>此后，输入：</p><div class="code-wrapper"><pre><code class="hljs bash">$ hexo -v</code></pre></div><p>来验证 Hexo 框架是否安装完成。</p><h2 id="3-使用-Hexo-搭建并查看本地网站"><a href="#3-使用-Hexo-搭建并查看本地网站" class="headerlink" title="3. 使用 Hexo 搭建并查看本地网站"></a>3. 使用 Hexo 搭建并查看本地网站</h2><p>完成此部分，您可以获得一个默认的博客网站。</p><h3 id="3-1-在指定路径创建博客文件夹"><a href="#3-1-在指定路径创建博客文件夹" class="headerlink" title="3.1. 在指定路径创建博客文件夹"></a>3.1. 在指定路径创建博客文件夹</h3><p>在您喜欢的路径上创建一个 Blog 文件夹后，在命令行输入（以下命令仅是示例，请按照此格式更改为您自己的文件夹）：</p><div class="code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> C:\Code\Blog</code></pre></div><p>便可跳转到此文件夹中。</p><h3 id="3-2-使用-Hexo-生成博客"><a href="#3-2-使用-Hexo-生成博客" class="headerlink" title="3.2. 使用 Hexo 生成博客"></a>3.2. 使用 Hexo 生成博客</h3><p>执行步骤3.1后，在命令行输入：</p><div class="code-wrapper"><pre><code class="hljs bash">$ hexo init</code></pre></div><p>来生成一个默认的新博客。</p><p><strong>您可能会遇到以下错误：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog0-0.png" alt="错误报告"></p><p>这是因为连接 GitHub 超时，您可以使用 VPN、更换网络或稍后再试。</p><p><strong>当最后一行出现：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">INFO Start blogging with Hexo!</code></pre></div><p>说明博客生成成功。</p><h3 id="3-3-本地查看网站"><a href="#3-3-本地查看网站" class="headerlink" title="3.3. 本地查看网站"></a>3.3. 本地查看网站</h3><p>在命令行输入（注意，务必在自己创建的博客目录下输入这条命令）：</p><div class="code-wrapper"><pre><code class="hljs bash">hexo s</code></pre></div><p>即可启动本地博客，默认地址一般为：<a href="http://localhost:4000/">http://localhost:4000/</a> 。您可在启动后展示的信息中找到此地址（黄色部分）：</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog0-1.png" alt="localhost"></p><p>该端口可能会被占用，此时修改默认启用的端口即可。</p><p>随后打开浏览器，输入该地址，您便会看到一个默认的博客页面：</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog0-2.png" alt="默认界面"></p><p>至此，博客便已搭建成功。</p><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>在<a href="https://hexo.io/zh-cn/docs/"> Hexo 官方文档 </a>中的Hexo概述中有这么一段话：</p><div class="code-wrapper"><pre><code class="hljs bash">安装 Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。$ npm install -g hexo-cli进阶安装和使用对于熟悉 npm 的进阶用户，可以仅局部安装 hexo 包。$ npm install hexo</code></pre></div><p><strong>那么 Hexo 和 Hexo-cli 有什么区别呢？</strong></p><p>hexo 包是基于 Node.js 的一个静态博客生成工具。而 hexo-cli 包则将 hexo 包中的功能封装为一个命令行工具。</p><p>换句话说：hexo-cli == Hexo Command Line Interface</p><p>例如，在执行：</p><div class="code-wrapper"><pre><code class="hljs bash">hexo init blog</code></pre></div><p>的时候，hexo-cli 会自动从 GitHub 中下载 hexo 到博客文件夹的 node_modules 目录下。</p><p>此外，上述流程中的 hexo 相关命令都是由于 hexo-cli 进行了封装，才能使用。</p><h2 id="4-使用Fluid主题美化博客"><a href="#4-使用Fluid主题美化博客" class="headerlink" title="4. 使用Fluid主题美化博客"></a>4. 使用Fluid主题美化博客</h2><p>完成此步骤，您将获得一个搭载了默认 Fluid 主题的静态博客。</p><p><img src="https://camo.githubusercontent.com/48b250de82787ee8090df0e3a3088e10d09a12b58fe1df55045f2476aca20978/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666c7569642d6465762f737461746963406d61737465722f6865786f2d7468656d652d666c7569642f73637265656e73686f74732f696e6465782e706e67" alt="Fluid主题预览"></p><p>该主题有详尽的中文用户手册，可自行进入 <a href="https://hexo.fluid-dev.com/docs/">Hexo Fluid 用户手册</a> 来添加该主题，以下仅提供一些注意事项。</p><h4 id="4-1-注意事项"><a href="#4-1-注意事项" class="headerlink" title="4.1. 注意事项"></a>4.1. 注意事项</h4><p>进入 博客文件夹\node_modules\hexo 路径中，打开 package.json 文件，便可查看hexo的版本：</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog0-3.png" alt="hexo版本"></p><p>在此文章发布时，该hexo版本是大于 5.0 的。因此在获取 Fluid 主题的最新版本时，推荐按照 Fluid 用户手册中的方法一来获取最新版本，不然可能在安装主题后执行：</p><div class="code-wrapper"><pre><code class="hljs bash">hexo s</code></pre></div><p>时，Fluid 主题会产生一个警告，按照方法一安装，则完美运行。</p><h2 id="5-将博客发布至-GitHub"><a href="#5-将博客发布至-GitHub" class="headerlink" title="5.将博客发布至 GitHub"></a>5.将博客发布至 GitHub</h2><p>完成此步骤，将会把个人博客部署至GitHub，实现在线浏览。</p><h3 id="5-1-在GitHub新建仓库"><a href="#5-1-在GitHub新建仓库" class="headerlink" title="5.1. 在GitHub新建仓库"></a>5.1. 在GitHub新建仓库</h3><p>在浏览器打开GitHub，登录后创建一个新仓库（Repository）：</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog0-4.png" alt="新仓库"></p><p>注意，仓库名必须要以你的用户名为开头，后跟 .github.io 。</p><p>最后滑到最下方点击 New Repository，则仓库创建成功。</p><h3 id="5-2-在博客目录下安装Git部署依赖"><a href="#5-2-在博客目录下安装Git部署依赖" class="headerlink" title="5.2. 在博客目录下安装Git部署依赖"></a>5.2. 在博客目录下安装Git部署依赖</h3><p>打开命令行，输入：</p><div class="code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> 博客目录路径</code></pre></div><p>进入博客目录。</p><p>随后，输入：</p><div class="code-wrapper"><pre><code class="hljs bash">$ npm install hexo-deployer-git --save</code></pre></div><p>来安装 Hexo 的 Git 部署工具。</p><h3 id="5-3-编辑博客目录下的-config-yml-文件"><a href="#5-3-编辑博客目录下的-config-yml-文件" class="headerlink" title="5.3. 编辑博客目录下的 _config.yml 文件"></a>5.3. 编辑博客目录下的 _config.yml 文件</h3><p>打开博客主目录下的 _config.yml 文件，找到 deploy 属性，进行如下图编辑：</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog0-5.png" alt="config文件编辑"></p><p>其中，repo 处填写创建项目的地址：</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog0-6.png" alt="地址"></p><p>编辑完成后，保存并关闭。</p><h3 id="5-4-将博客部署至GitHub"><a href="#5-4-将博客部署至GitHub" class="headerlink" title="5.4. 将博客部署至GitHub"></a>5.4. 将博客部署至GitHub</h3><p>打开命令行工具，移动到博客目录，输入：</p><div class="code-wrapper"><pre><code class="hljs bash">$ hexo d</code></pre></div><p>随后在弹出的图形界面或命令行界面输入GitHub的账号密码即可完成部署。</p><p>最后，在浏览器地址栏输入仓库名即可访问博客。</p>]]></content>
    
    
    <categories>
      
      <category>静态博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>hexo-fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
