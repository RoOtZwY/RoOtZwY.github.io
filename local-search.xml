<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Servlet基础知识点回顾（一）</title>
    <link href="/2021/10/04/Servlet%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2021/10/04/Servlet%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本篇文章用于简易回顾Servlet基础知识，并阅读自己之前项目里写过的一些Servlet代码。</p><span id="more"></span><h1 id="Servlet基础知识点回顾（一）"><a href="#Servlet基础知识点回顾（一）" class="headerlink" title="Servlet基础知识点回顾（一）"></a>Servlet基础知识点回顾（一）</h1><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog3-0.jpg" alt="Servlet生命周期"></p><h2 id="什么是Servlet？"><a href="#什么是Servlet？" class="headerlink" title="什么是Servlet？"></a>什么是Servlet？</h2><p>Servlet是Sun公司专门用于开发动态Web网页的一门技术，Servlet API中封存了大量的接口和一些实现类来帮助程序员处理web请求和响应。Servlet规定了一系列接口规范，是软件项目工程化的重要体现。</p><p>Servlet需要在web.xml中配置路径名和映射，将Servlet映射到Web容器中，并指定Servlet需要处理的路径，Web容器才能找到这个Servlet并进行处理。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.rootzwy.servlet.HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre></div><p>第一个Servlet程序：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        PrintWriter writer = resp.getWriter();        writer.println(<span class="hljs-string">&quot;Hello, Servlet!&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;    &#125;</code></pre></div><h2 id="Servlet基本原理"><a href="#Servlet基本原理" class="headerlink" title="Servlet基本原理"></a>Servlet基本原理</h2><p>以HTTP协议为例，浏览器端发送HTTP请求到Web容器，Web容器接收到这个请求，并将其中诸如请求头、请求体等信息封装为<code>HttpServletRequest</code>对象，同时也创建一个<code>HttpServletResponse</code>对象。在浏览器端首次访问时，创建特定的<code>Servlet</code>对象，这个对象用于处理收到的请求对象，并且编辑响应对象，再将响应对象回传给Web容器，Web容器将响应对象读取转换后发送给浏览器端。</p><h2 id="Servlet映射问题"><a href="#Servlet映射问题" class="headerlink" title="Servlet映射问题"></a>Servlet映射问题</h2><p>一个Servlet可以指定一个映射路径。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.rootzwy.servlet.HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre></div><p>一个Servlet可以指定多个映射路径。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.rootzwy.servlet.HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello1<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello2<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre></div><p>一个Servlet可以指定通用路径。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.rootzwy.servlet.HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><span class="hljs-comment">&lt;!-- 或者指定以特定后缀结尾的路径 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 例如：localhost:8080/asdf/hello.zwy --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.rootzwy<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre></div><p>一个Servlet可以覆盖<code>index</code>。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.rootzwy.servlet.HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><span class="hljs-comment">&lt;!-- 对于具体的路径，Servlet会优先走具体路径，比如 /hello --&gt;</span></code></pre></div><h2 id="Servlet中的常用对象和方法"><a href="#Servlet中的常用对象和方法" class="headerlink" title="Servlet中的常用对象和方法"></a>Servlet中的常用对象和方法</h2><h3 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a>HttpServlet</h3><p><code>HttpServlet</code>是一个抽象类，继承自<code>GenericServlet</code>类，实现了<code>Servlet</code>接口，封装了一些处理Web请求响应和Servlet管理的方法，例如经典的<code>doGet()</code>、<code>doPost()</code>、<code>getServletContext()</code>等。程序员通过继承此类来重写对应方法，经过<code>service()</code>方法来处理请求和响应。</p><h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><p>Web容器启动时，Web容器为每一个Web程序都创建一个<code>ServletContext</code>对象，来充当Web程序和Web容器的上下文，每个<code>Servlet</code>对象代表一个Web程序。以下列出<code>ServletContext</code>的一些常见基本功能。</p><p>Servlet间共享数据：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// In Servlet1</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException</span><span class="hljs-function"></span>&#123;    ServletContext context = <span class="hljs-keyword">this</span>.getServletContext();    String userName = <span class="hljs-string">&quot;zwy&quot;</span>;    <span class="hljs-comment">// 将userName存放进ServletContext中，将在Servlet2中访问这个属性</span>    context.setAttribute(<span class="hljs-string">&quot;userName&quot;</span>, userName);&#125;<span class="hljs-comment">// In Servlet2</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;    ServletContext context = <span class="hljs-keyword">this</span>.getServletContext();    <span class="hljs-comment">// 从ServletContext获取userName</span>    String userName = (String) context.getAttribute(<span class="hljs-string">&quot;userName&quot;</span>);    PrintWriter writer = resp.getWriter();    resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);    resp.setContentType(<span class="hljs-string">&quot;text/html&quot;</span>);    <span class="hljs-comment">// 输出userName</span>    writer.println(<span class="hljs-string">&quot;Hello, &quot;</span> + userName);&#125;</code></pre></div><p>获取web.xml相应元素：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- In web.xml --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">contxt-param</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>mysqlUrl<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>jdbc:mysql://localhors:3306<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">contxt-param</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// In Servlet</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;    ServletContext context = <span class="hljs-keyword">this</span>.getServletContect();    String url = context.getInitParameter(<span class="hljs-string">&quot;mysqlUrl&quot;</span>);    resp.getwriter().println(url);&#125;</code></pre></div><p> 读取资源文件</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// In Servlet</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;    <span class="hljs-comment">// 此处是编译之后资源文件的路径</span>    InputStream is = <span class="hljs-keyword">this</span>.getServletContext().getResourceAsStream(<span class="hljs-string">&quot;/WEB-INF/classes/test.properties&quot;</span>);    Properties properties = <span class="hljs-keyword">new</span> Properties();    properties.load(is);    String name = properties.getProperty(<span class="hljs-string">&quot;username&quot;</span>);    String pwd = properties.getProperty(<span class="hljs-string">&quot;password&quot;</span>);    PrintWriter writer = resp.getWriter();    resp.setContentType(<span class="hljs-string">&quot;text/html&quot;</span>);   resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);    writer.println(<span class="hljs-string">&quot;User: &quot;</span> + name);    writer.println(<span class="hljs-string">&quot;Password: &quot;</span> + pwd);&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># In properties</span><span class="hljs-attr">username</span>=<span class="hljs-string">root</span><span class="hljs-attr">password</span>=<span class="hljs-string">123456</span></code></pre></div><h3 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h3><p><code>HttpServletResponse</code>是一个接口，继承了<code>ServletResponse</code>。Web容器在接收到请求时，会针对这个请求，默认创建一个实现这个响应接口的对象，用于封装响应，让程序员通过代码去操作响应信息。</p><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function">PrintWriter <span class="hljs-title">getWriter</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<span class="hljs-function">ServletOutputStream <span class="hljs-title">getOutputStream</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setCharacterEncoding</span><span class="hljs-params">(String var1)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setContentLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span> var1)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setContentType</span><span class="hljs-params">(String var1)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setDateHeader</span><span class="hljs-params">(String var1, <span class="hljs-keyword">long</span> var2)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addDateHeader</span><span class="hljs-params">(String var1, <span class="hljs-keyword">long</span> var2)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setHeader</span><span class="hljs-params">(String var1, String var2)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addHeader</span><span class="hljs-params">(String var1, String var2)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setIntHeader</span><span class="hljs-params">(String var1, <span class="hljs-keyword">int</span> var2)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addIntHeader</span><span class="hljs-params">(String var1, <span class="hljs-keyword">int</span> var2)</span></span>;<span class="hljs-comment">// ......</span></code></pre></div><h4 id="常见应用"><a href="#常见应用" class="headerlink" title="常见应用"></a>常见应用</h4><h5 id="向浏览器输出文本或其它数据。"><a href="#向浏览器输出文本或其它数据。" class="headerlink" title="向浏览器输出文本或其它数据。"></a>向浏览器输出文本或其它数据。</h5><p>例如下载文件：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;    <span class="hljs-comment">// 获取下载文件的路径</span>    ServletContext context = <span class="hljs-keyword">this</span>.getServletContext();    String path = context.getRealPath(<span class="hljs-string">&quot;/WEB-INF/classes/txt/yinsha.txt&quot;</span>);    String fileName = path.substring(path.lastIndexOf(<span class="hljs-string">&quot;\\&quot;</span>) + <span class="hljs-number">1</span>);    System.out.println(<span class="hljs-string">&quot;输出文件的名称： &quot;</span> + fileName);    <span class="hljs-comment">// 设置浏览器下载头和编码格式</span>    resp.setHeader(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment;filename=&quot;</span>            + URLEncoder.encode(fileName, StandardCharsets.UTF_8));<span class="hljs-comment">// resp.setContentType(&quot;text/html&quot;); // 若指定当前页面为html，则下载的文件都是html文件</span>    resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);    <span class="hljs-comment">// 获取文件流</span>    FileInputStream in = <span class="hljs-keyword">new</span> FileInputStream(path);    <span class="hljs-comment">// 创建缓冲区</span>    <span class="hljs-keyword">int</span> len;    <span class="hljs-keyword">byte</span>[] fileBuffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];    <span class="hljs-comment">// 获取输出流</span>    ServletOutputStream out = resp.getOutputStream();    <span class="hljs-comment">// 输出流从Buffer获取文件流</span>    <span class="hljs-keyword">while</span> ((len = in.read(fileBuffer)) != -<span class="hljs-number">1</span>) &#123;        out.write(fileBuffer, <span class="hljs-number">0</span>, len);    &#125;    out.close();    in.close();&#125;</code></pre></div><p>实现简易的动态验证码：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityCodeImgServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        <span class="hljs-comment">// 网页定时刷新</span>        resp.setHeader(<span class="hljs-string">&quot;refresh&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>);        <span class="hljs-comment">// 在缓存中创建一个图片</span>        BufferedImage image = <span class="hljs-keyword">new</span> BufferedImage(<span class="hljs-number">80</span>, <span class="hljs-number">20</span>, BufferedImage.TYPE_INT_RGB);        <span class="hljs-comment">// 得到图片的画笔，并写入验证码</span>        Graphics2D imgGraphics = (Graphics2D) image.getGraphics();<span class="hljs-comment">//        Graphics2D imgGraphics = image.createGraphics();</span>        imgGraphics.setColor(Color.WHITE);        imgGraphics.fillRect(<span class="hljs-number">0</span> ,<span class="hljs-number">0</span>, <span class="hljs-number">80</span>, <span class="hljs-number">20</span>);        imgGraphics.setColor(Color.BLACK);        imgGraphics.setFont(<span class="hljs-keyword">new</span> Font(<span class="hljs-keyword">null</span>, Font.BOLD, <span class="hljs-number">20</span>));        imgGraphics.drawString(randomSecurityCodeString(), <span class="hljs-number">0</span>, <span class="hljs-number">20</span>);        <span class="hljs-comment">// 告诉浏览器响应页面的格式</span>        resp.setContentType(<span class="hljs-string">&quot;image/png&quot;</span>);        <span class="hljs-comment">// Expires表示存在时间，允许客户端在这个时间之前不去检查（发请求）</span>        resp.setDateHeader(<span class="hljs-string">&quot;expires&quot;</span>, -<span class="hljs-number">1</span>);        <span class="hljs-comment">// Cache-control 用于控制HTTP缓存（在HTTP/1.0中可能部分没实现，仅仅实现了 Pragma: no-cache）</span>        resp.setHeader(<span class="hljs-string">&quot;Cache-Control&quot;</span>, <span class="hljs-string">&quot;no-cache&quot;</span>);        resp.setHeader(<span class="hljs-string">&quot;Pragma&quot;</span>, <span class="hljs-string">&quot;no-cache&quot;</span>);        <span class="hljs-comment">// 把图片写给浏览器(formatName必须是可以使用的图片后缀名)</span>        ImageIO.write(image, <span class="hljs-string">&quot;png&quot;</span>, resp.getOutputStream());    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">randomSecurityCodeString</span><span class="hljs-params">()</span> </span>&#123;        Random random = <span class="hljs-keyword">new</span> Random();        <span class="hljs-comment">// 设置编码为7位</span>        <span class="hljs-keyword">int</span> digit = <span class="hljs-number">7</span>;        <span class="hljs-comment">// 生成编码字符串</span>        <span class="hljs-keyword">int</span> limit = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; digit; i++) &#123;            limit *= <span class="hljs-number">10</span>;        &#125;        String randomNum = <span class="hljs-string">&quot;&quot;</span> + random.nextInt(limit);                <span class="hljs-comment">// 字符串前置补0</span>        StringBuffer stringBuffer = <span class="hljs-keyword">new</span> StringBuffer();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; digit - randomNum.length(); i++) &#123;            stringBuffer.append(<span class="hljs-string">&quot;0&quot;</span>);        &#125;        stringBuffer.append(randomNum);        <span class="hljs-keyword">return</span> stringBuffer.toString();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre></div><h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sendRedirect</span><span class="hljs-params">(String var1)</span> <span class="hljs-keyword">throws</span> IOException</span>; <span class="hljs-comment">// var1是web路径名，如：hello（没有web主路径的&quot;/&quot;）</span></code></pre></div><p>登录重定向和请求转发流程：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;    <span class="hljs-comment">// 在一个Servlet中重定向到负责登录的jsp或Servlet</span>    resp.sendRedirect(<span class="hljs-string">&quot;login.jsp&quot;</span>);&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs jsp">&lt;%-- 在此页面（login.jsp）获取用户名信息，然后POST到action下的Servlet页面--%&gt;&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/waiting&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;    用户名：    &lt;label&gt;        &lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;username&quot;</span>&gt;    &lt;/label&gt; &lt;br&gt;    密 码：    &lt;label&gt;        &lt;input type=<span class="hljs-string">&quot;password&quot;</span> name=<span class="hljs-string">&quot;password&quot;</span>&gt;    &lt;/label&gt; &lt;br&gt;    识别码：    &lt;label&gt;        &lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;uid&quot;</span>&gt;    &lt;/label&gt; &lt;br&gt;    &lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 在此Servlet中可以获取用户名密码，并进行操作，登录成功后请求转发或重定向到WelcomeServlet</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">loginWaitingServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        String uid = req.getParameter(<span class="hljs-string">&quot;uid&quot;</span>);        String uname = req.getParameter(<span class="hljs-string">&quot;username&quot;</span>);        <span class="hljs-keyword">if</span> (!uid.equals(<span class="hljs-string">&quot;root&quot;</span>)) &#123;            resp.sendRedirect(<span class="hljs-string">&quot;pwdError&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//            resp.sendRedirect(&quot;welcome&quot;);</span>            <span class="hljs-comment">// 请求转发传递数据</span>            RequestDispatcher dispatcher = req.getRequestDispatcher(<span class="hljs-string">&quot;welcome&quot;</span>);            dispatcher.forward(req, resp);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(req, resp);    &#125;&#125;</code></pre></div><h3 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h3><p><code>HttpServletRequest</code>是一个接口，继承了<code>ServletRequest</code>。Web容器在接收到通过HTTP协议发送过来的请求时，会针对这个请求，默认创建一个实现这个请求接口的对象，用于封装请求的所有信息，让程序员通过代码去操作请求信息。</p><h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 几乎所有...</span></code></pre></div><h4 id="常见应用-1"><a href="#常见应用-1" class="headerlink" title="常见应用"></a>常见应用</h4><h5 id="获取前端参数"><a href="#获取前端参数" class="headerlink" title="获取前端参数"></a>获取前端参数</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 用于获取普通的前端参数</span><span class="hljs-function">String <span class="hljs-title">getParameter</span><span class="hljs-params">(String var1)</span></span>;<span class="hljs-comment">// 用于获取有多个值的前端参数</span> String[] getParameterValues(String var1);</code></pre></div><h5 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function">RequestDispatcher <span class="hljs-title">getRequestDispatcher</span><span class="hljs-params">(String var1)</span></span>;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Java Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Servlet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java虚拟机运行时数据区域概述</title>
    <link href="/2021/09/05/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%E6%A6%82%E8%BF%B0/"/>
    <url>/2021/09/05/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>Java虚拟机运行时，内存布局中各个数据区域的简要概述。</p><span id="more"></span><h1 id="Java虚拟机运行时数据区域"><a href="#Java虚拟机运行时数据区域" class="headerlink" title="Java虚拟机运行时数据区域"></a>Java虚拟机运行时数据区域</h1><p>JVM 内存布局其一</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog2-0.png" alt="JVM内存布局其一"></p><p>JVM内存布局其二</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog2-1.png" alt="JVM内存布局其二"></p><p>《深入理解Java虚拟机》JVM内存布局</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog2-2.png" alt="书中JVM内存布局"></p><h2 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h2><p>程序计数器是一块比较小的内存空间，它可以看做是当前线程所执行字节码的行号显示器。在Java虚拟机的概念模型里，<strong>字节码解释器工作时就是通过改变这个计数器的值来选取下一条执行的字节码指令的</strong>，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>在Java虚拟机中，多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，因此每个时刻只会执行一个线程中的指令，因此，为了线程切换后能恢复到正确的执行位置，<strong>每个线程都有一个独立的程序计数器</strong>。</p><p><strong>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是<code>Native</code>方法，这个计数器值则应为<code>Undefined</code>。</strong>此内存区域是唯 一一个在《Java虚拟机规范》中没有规定任何<code>OutOfMemoryError</code>情况的区域。</p><h2 id="Java虚拟机栈（Java-Visual-Machine-Stack）"><a href="#Java虚拟机栈（Java-Visual-Machine-Stack）" class="headerlink" title="Java虚拟机栈（Java Visual Machine Stack）"></a>Java虚拟机栈（Java Visual Machine Stack）</h2><p><strong>Java虚拟机栈和程序计数器一样是线程私有的，它的生命周期和线程相同。</strong>虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信 息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><p>局部变量表存放了编译期可知的各种Java虚拟机基本数据类型、对象引用（<code>reference</code>类型，它并不等同于对象本身，可能是一个指向对象起始 地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和<code>returnAddress</code> 类型（指向了一条字节码指令的地址）。</p><p><strong>这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示，其中64位长度的<code>long</code>和 <code>double</code>类型的数据会占用两个变量槽，其余的数据类型只占用一个。</strong>局部变量表所需的内存空间在编译期间完成分配，<strong>当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的</strong>，在方法运行期间不会改变局部变量表的大小。请注意，这里说的“大小”是指变量槽的数量， <strong>虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一个变量槽，这是完全由具体的虚拟机实现自行决定的事情。</strong> </p><p>在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出<code>StackOverflowError</code>异常；如果Java虚拟机栈容量可以动态扩展（HotSpot虚拟机的栈容量是不可以动态拓展的），当栈扩 展时无法申请到足够的内存会抛出<code>OutOfMemoryError</code>异常。</p><h2 id="本地方法栈（Native-Method-Stacks）"><a href="#本地方法栈（Native-Method-Stacks）" class="headerlink" title="本地方法栈（Native Method Stacks）"></a>本地方法栈（Native Method Stacks）</h2><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别只是<strong>虚拟机栈为虚拟机执行Java方法（即字节码）服务，而本地方法栈则是为虚拟机使用到的<code>Native</code> 方法服务</strong>。</p><p>与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失 败时分别抛出<code>StackOverflowError</code>和<code>OutOfMemoryError</code>异常。</p><h2 id="Java堆（Java-Heap）"><a href="#Java堆（Java-Heap）" class="headerlink" title="Java堆（Java Heap）"></a>Java堆（Java Heap）</h2><p>Java堆是虚拟机所管理的内存中最大的一块。<strong>Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例</strong>，Java 世界里<strong>几乎</strong>所有的对象实例都在这里分配内存。在《Java虚拟机规范》中对Java堆的描述是：“所有的对象实例以及数组都应当在堆上分配”，而这里的“几乎”是指从实现角度来看，随着Java语言的发展，Java对象实例都分配在堆上也渐渐变得不是那么绝对了。</p><p><strong>Java堆是垃圾收集器管理的内存区域</strong>，一些资料中它也被称作<strong>GC堆</strong>（Garbage Collected Heap）。从回收内存的角度看，由于<strong>现代垃圾收集器大部分都是基于分代收集理论设计的</strong>，因此Java堆常常会被划分为许多区域，比如<strong>经典分代</strong>（新生代、老年代），但这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格而已，而非某个Java虚拟机具体实现的固有内存布局，更不是《Java虚拟机规范》里对Java堆的进一步细致划分。到了今天，垃圾收集器技术与十年前已不可同日而语，HotSpot里面也出现了不采用分代设计的新垃圾收集器。</p><p>如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区 （Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。但无论是哪个区域，存储的都只能是对象的实例，将Java堆细分的目的只是为了更好地回收内存，或者更快地分配内存。</p><p>根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的，这点就像用磁盘空间去存储文件一样，并不要求每个文件都连续存放。但对于<strong>大对象（典型的如数组对象）</strong>，多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。</p><p>Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数设定）。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出<code>OutOfMemoryError</code>异常。</p><h2 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h2><p>方法区与Java堆一样，是各个线程共享的内存区域，它<strong>用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。虽然<strong>《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分（比如字符串常量池，逻辑上属于方法区，但实际放置于Java堆）</strong>，但是它却有一个别名叫作“非堆”（Non-Heap），目的是与Java堆区分开来。</p><p>注意：</p><p>在JDK1.8之后，方法区的实现方法从永久代彻底替换为元空间（Meta-space）。因为在永久代中，容易出现性能问题和内存溢出，因为永久代有<code>-XX: MaxPermSize</code>的上限，即便不设置也有默认大小。</p><p>在JDK1.7之后，方法区中的字符串常量池、静态变量<strong>等</strong>移至Java堆放置。</p><p>《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的确是比较少出现的，这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收效果比较难令人满意，尤 其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。</p><p>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出<code> OutOfMemoryError</code>异常。</p><h3 id="JDK-8后，永久代去哪了？"><a href="#JDK-8后，永久代去哪了？" class="headerlink" title="JDK 8后，永久代去哪了？"></a>JDK 8后，永久代去哪了？</h3><p><a href="https://www.zhihu.com/question/39990490/answer/84155229">JDK8之后，永久代去哪了？</a></p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog2-3.png" alt="永久代去哪了？"></p><p><a href="https://www.zhihu.com/question/438698030/answer/1670533755">拓展知识：虚拟机之于本地内存</a></p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog2-4.jpg" alt="虚拟机之于本地内存"></p><p><a href="https://zhuanlan.zhihu.com/p/111809384">元空间和永久代的详细区别</a></p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog2-5.jpg" alt="内存划分对比"></p><h3 id="运行时常量池（Runtime-Constant-Pool）"><a href="#运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="运行时常量池（Runtime Constant Pool）"></a>运行时常量池（Runtime Constant Pool）</h3><p>运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p> Java虚拟机对于Class文件每一部分（自然也包括常量池）的格式都有严格规定，如每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、加载和执行，但对于运行时常量池， 《Java虚拟机规范》并没有做任何细节的要求，不同提供商实现的虚拟机可以按照自己的需要来实现 这个内存区域，不过一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中。 </p><p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是<code>String</code>类的 <code>intern()</code>方法。 既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存 时会抛出<code>OutOfMemoryError</code>异常。</p><h2 id="直接内存（Direct-Memory）"><a href="#直接内存（Direct-Memory）" class="headerlink" title="直接内存（Direct Memory）"></a>直接内存（Direct Memory）</h2><p>直接内存并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致<code>OutOfMemoryError</code>异常出现，因此放在此处讨论。 </p><p>在JDK1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区 （Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的 <code>DirectByteBuffer</code>对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。 显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务 器管理员配置虚拟机参数时，会根据实际内存去设置<code>-Xmx</code>等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现 <code>OutOfMemoryError</code>异常。</p>]]></content>
    
    
    <categories>
      
      <category>Java虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java虚拟机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法基础知识回顾</title>
    <link href="/2021/04/14/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"/>
    <url>/2021/04/14/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/</url>
    
    <content type="html"><![CDATA[<p>回顾学习算法时所必须了解的一些基本知识。</p><span id="more"></span><p>本篇文章用于简要梳理在算法中的一些需要了解的基本知识点。</p><h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><p><strong>To measure is to know. If you can not measure it, you can not improve it.</strong></p><p>本部分通过引入理想、统一、分层次的尺度标准，来衡量算法的性能。</p><h2 id="大O记号"><a href="#大O记号" class="headerlink" title="大O记号"></a>大O记号</h2><p>大O记号通过划分上界，来悲观地衡量一个算法的性能。</p><p>注意：O(f(n)) 并不一定会完全处于 T(n) 之上，但可以通过如图中对 f(n) 乘以常系数 c 来做到拉高上界的作用。</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog1-0.png" alt="大O记号"></p><h2 id="其它记号"><a href="#其它记号" class="headerlink" title="其它记号"></a>其它记号</h2><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog1-1.png" alt="其他记号"></p><h2 id="大O记号的刻度"><a href="#大O记号的刻度" class="headerlink" title="大O记号的刻度"></a>大O记号的刻度</h2><p><strong>常数复杂度 O( 1 )</strong></p><p>算法不含随输入规模变换的转向（循环、调用、递归等），且顺序执行，则说这个算法的复杂度为 O(1)。</p><p><strong>对数复杂度 O( log^c(n) )</strong></p><p>在此种情况中，对数的底数常常会被忽略，因为往往可以通过数学变换来改变对数的底数。</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog1-2.png" alt="底数变换"></p><p>这类算法非常高效，复杂度无限接近于常数。</p><p><strong>多项式复杂度 O( n^c )</strong></p><p>此种复杂度由于影响因素往往取决于最高次幂项，因此较低次幂的项往往忽略不计。</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog1-3.png" alt="多项式复杂度"></p><p>其中，当幂次 c == 1 时，表示算法的时间复杂度与 n 线性相关，因此称 O(n) 为线性复杂度。</p><p><strong>指数复杂度 O( 2^n )</strong></p><p>当一个算法的计算成本按指数增长时，往往我们认为此种算法为问题的难解。</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog1-4.png" alt="指数复杂度"></p><p>我们可以从下图中观察各个复杂度的增长速度：</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog1-5.png" alt="复杂度的增长速度"></p><h2 id="级数"><a href="#级数" class="headerlink" title="级数"></a>级数</h2><p>以下图片总结了一些常见的级数。</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog1-6.png" alt="级数1"></p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog1-7.png" alt="级数2"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Hexo博客框架搭建静态博客</title>
    <link href="/2021/04/06/%E4%BD%BF%E7%94%A8Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/04/06/%E4%BD%BF%E7%94%A8Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>本篇文章用于记录如何在 Windows 中使用 Hexo 博客框架搭建个人静态博客。</p><span id="more"></span><p>在该篇文章中，您将会看到：静态博客搭建相关技术简介、博客搭建流程、使用主题来美化博客，最后将博客发布至 GitHub。</p><p>一些碎语：</p><p>在不同的操作系统中搭建静态博客的方法大同小异，因此此篇文章步骤也基本适用于其它操作系统。</p><p>博客搭建过程中难免会遇到不同问题，您可能和本人一样有着轻微的强迫症，不容许搭建过程中产生半点冗余内容，不用担心，此博客的所有内容都汇集在一个文件夹中，若搭建过程中遇到难以解决的问题，直接干掉未搭建完成的博客文件夹即可，而且如果完全按照此文章进行博客创建，途中产生的警告可完全忽略。</p><p>个人在两种操作系统中都搭建过静态博客，由于文件系统和权限等原因，在 Linux 中的安装流程更为顺畅，但由于Windows环境下能更加方便地编写发布博客，因此最后选择了 Windows。</p><p>此后可能会写将博客部署到云服务器的操作流程，但这是后话了，此时先专注于本篇文章。</p><h1 id="相关内容简介"><a href="#相关内容简介" class="headerlink" title="相关内容简介"></a>相关内容简介</h1><p>对相关技术了解较深或不感兴趣可以跳过该部分。</p><p>该部分将会简要介绍搭建静态博客时所涉及到的部分术语和相关技术，仅做简要介绍，具体请自行进行搜索。</p><p><strong>动态博客和静态博客</strong></p><p>此处的两种术语表示了两种不同的博客搭建形式，基本类似于静态网站和动态网站的区别。</p><p>动态博客，是指具有前端和后端的动态博客网站，类似于 CSDN、博客园等博客论坛，可以实现网站代码编写和功能使用的分离，其灵活性、易用性和功能性相较于静态博客都比较高。</p><p>静态博客，是指使用纯前端的形式搭建的静态博客网站，由于没有后台管理，因此对静态博客的每一个操作都与代码耦合，更难使用且功能更少，并且缺少动态交互。</p><p><strong>Hexo</strong></p><p>Hexo 是一个快速、简洁且高效的静态博客框架。该框架基于Node.js运行环境，能够帮助我们快速地搭建静态博客。</p><p><strong>Node.js</strong></p><p>“Node.js is a JavaScript runtime built on Chrome’s V8 JavaScript Engine.”</p><p>Node.js 不是一门编程语言，而是基于Chrome V8引擎的JavaScript语言运行环境，是一种宿主环境，类似于浏览器。</p><p><strong>GitHub</strong></p><p>GitHub 是一个开源的软件项目托管平台，由于其使用 Git 作为版本库格式进行托管，因此被命名为 GitHub。</p><p><strong>Git</strong></p><p>Git 是目前世界上较为先进的分布式版本控制系统，通过 Git，您可以方便地对项目的改动进行记录，还可以与其他人进行协作编辑，从而实现对项目的版本进行管理。</p><h1 id="静态博客搭建流程（Windows）"><a href="#静态博客搭建流程（Windows）" class="headerlink" title="静态博客搭建流程（Windows）"></a>静态博客搭建流程（Windows）</h1><p>该部分将展示 Windows 10 系统下静态博客的搭建流程，其中省略了一些较为简单的操作步骤。</p><p><strong>强烈建议在管理员模式下的命令行执行该流程。</strong></p><h2 id="1-下载-Node-js-和-Git"><a href="#1-下载-Node-js-和-Git" class="headerlink" title="1. 下载 Node.js 和 Git"></a>1. 下载 Node.js 和 Git</h2><p>个人建议从官方网站下载最新版本的Node.js和Git。</p><p><a href="https://nodejs.org/">Node.js 官方网站</a></p><p><a href="https://git-scm.com/">Git 官方网站</a></p><p>关于 Node.js 和 Git 的详细安装和环境配置流程，由于不属于本篇的主要内容，且流程对后续步骤影响不大，故不再列出，您可自行进行搜索，或直接采用默认的安装选项安装即可，必须确保两者被成功安装。</p><p><strong>检查 Node.js 和 Git 是否安装以及配置成功</strong></p><p>打开 Windows 的命令行工具，输入：</p><div class="code-wrapper"><pre><code class="hljs bash">$ node -v</code></pre></div><p>若弹出 Node.js 版本信息，说明 Node.js 安装成功。</p><p>输入：</p><div class="code-wrapper"><pre><code class="hljs bash">$ git</code></pre></div><p>若弹出 Git 的命令使用说明，说明 Git 安装成功。</p><h2 id="2-通过-Node-js-的-npm-安装-Hexo"><a href="#2-通过-Node-js-的-npm-安装-Hexo" class="headerlink" title="2. 通过 Node.js 的 npm 安装 Hexo"></a>2. 通过 Node.js 的 npm 安装 Hexo</h2><p>完成此部分，您就基本准备好了博客搭建所需要的工具。</p><p><strong>npm</strong></p><p>Node.js 的包管理器，允许客户从npm服务器中下载第三方的包到本地使用。在 Node.js 安装时自带。</p><h3 id="2-1-安装-cnpm（可选）"><a href="#2-1-安装-cnpm（可选）" class="headerlink" title="2.1. 安装 cnpm（可选）"></a>2.1. 安装 cnpm（可选）</h3><p>由于 npm 的镜像位于国外，因此下载速度较慢，cnpm 是中国的 npm 镜像客户端，此处将 cnpm 的镜像源指向淘宝的镜像源，后续的 npm 命令可以使用 cnpm 代替，npm 命令的详细含义可自行百度搜索，此处不再列出。</p><p>若您对所处的网络环境很自信，或者有 VPN，觉得没有这个必要，可跳过此步骤。</p><p>进入 Windows 命令行工具，输入：</p><div class="code-wrapper"><pre><code class="hljs bash">$ npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre></div><p>此后，输入：</p><div class="code-wrapper"><pre><code class="hljs bash">$ cnpm</code></pre></div><p>若弹出 cnpm 的命令使用说明，说明 cnpm 安装成功。</p><p>此处 cnpm 被安装在 npm 的默认路径，您可以通过修改此路径来统一管理包。</p><h3 id="2-2-安装Hexo"><a href="#2-2-安装Hexo" class="headerlink" title="2.2. 安装Hexo"></a>2.2. 安装Hexo</h3><p><strong>若您安装了 cnpm，将下面的 npm 改为 cnpm 即可。</strong></p><p>打开 Windows 命令行，输入：</p><div class="code-wrapper"><pre><code class="hljs bash">$ npm install -g hexo-cli</code></pre></div><p>此后，输入：</p><div class="code-wrapper"><pre><code class="hljs bash">$ hexo -v</code></pre></div><p>来验证 Hexo 框架是否安装完成。</p><h2 id="3-使用-Hexo-搭建并查看本地网站"><a href="#3-使用-Hexo-搭建并查看本地网站" class="headerlink" title="3. 使用 Hexo 搭建并查看本地网站"></a>3. 使用 Hexo 搭建并查看本地网站</h2><p>完成此部分，您可以获得一个默认的博客网站。</p><h3 id="3-1-在指定路径创建博客文件夹"><a href="#3-1-在指定路径创建博客文件夹" class="headerlink" title="3.1. 在指定路径创建博客文件夹"></a>3.1. 在指定路径创建博客文件夹</h3><p>在您喜欢的路径上创建一个 Blog 文件夹后，在命令行输入（以下命令仅是示例，请按照此格式更改为您自己的文件夹）：</p><div class="code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> C:\Code\Blog</code></pre></div><p>便可跳转到此文件夹中。</p><h3 id="3-2-使用-Hexo-生成博客"><a href="#3-2-使用-Hexo-生成博客" class="headerlink" title="3.2. 使用 Hexo 生成博客"></a>3.2. 使用 Hexo 生成博客</h3><p>执行步骤3.1后，在命令行输入：</p><div class="code-wrapper"><pre><code class="hljs bash">$ hexo init</code></pre></div><p>来生成一个默认的新博客。</p><p><strong>您可能会遇到以下错误：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog0-0.png" alt="错误报告"></p><p>这是因为连接 GitHub 超时，您可以使用 VPN、更换网络或稍后再试。</p><p><strong>当最后一行出现：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">INFO Start blogging with Hexo!</code></pre></div><p>说明博客生成成功。</p><h3 id="3-3-本地查看网站"><a href="#3-3-本地查看网站" class="headerlink" title="3.3. 本地查看网站"></a>3.3. 本地查看网站</h3><p>在命令行输入（注意，务必在自己创建的博客目录下输入这条命令）：</p><div class="code-wrapper"><pre><code class="hljs bash">hexo s</code></pre></div><p>即可启动本地博客，默认地址一般为：<a href="http://localhost:4000/">http://localhost:4000/</a> 。您可在启动后展示的信息中找到此地址（黄色部分）：</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog0-1.png" alt="localhost"></p><p>该端口可能会被占用，此时修改默认启用的端口即可。</p><p>随后打开浏览器，输入该地址，您便会看到一个默认的博客页面：</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog0-2.png" alt="默认界面"></p><p>至此，博客便已搭建成功。</p><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>在<a href="https://hexo.io/zh-cn/docs/"> Hexo 官方文档 </a>中的Hexo概述中有这么一段话：</p><div class="code-wrapper"><pre><code class="hljs bash">安装 Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。$ npm install -g hexo-cli进阶安装和使用对于熟悉 npm 的进阶用户，可以仅局部安装 hexo 包。$ npm install hexo</code></pre></div><p><strong>那么 Hexo 和 Hexo-cli 有什么区别呢？</strong></p><p>hexo 包是基于 Node.js 的一个静态博客生成工具。而 hexo-cli 包则将 hexo 包中的功能封装为一个命令行工具。</p><p>换句话说：hexo-cli == Hexo Command Line Interface</p><p>例如，在执行：</p><div class="code-wrapper"><pre><code class="hljs bash">hexo init blog</code></pre></div><p>的时候，hexo-cli 会自动从 GitHub 中下载 hexo 到博客文件夹的 node_modules 目录下。</p><p>此外，上述流程中的 hexo 相关命令都是由于 hexo-cli 进行了封装，才能使用。</p><h2 id="4-使用Fluid主题美化博客"><a href="#4-使用Fluid主题美化博客" class="headerlink" title="4. 使用Fluid主题美化博客"></a>4. 使用Fluid主题美化博客</h2><p>完成此步骤，您将获得一个搭载了默认 Fluid 主题的静态博客。</p><p><img src="https://camo.githubusercontent.com/48b250de82787ee8090df0e3a3088e10d09a12b58fe1df55045f2476aca20978/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666c7569642d6465762f737461746963406d61737465722f6865786f2d7468656d652d666c7569642f73637265656e73686f74732f696e6465782e706e67" alt="Fluid主题预览"></p><p>该主题有详尽的中文用户手册，可自行进入 <a href="https://hexo.fluid-dev.com/docs/">Hexo Fluid 用户手册</a> 来添加该主题，以下仅提供一些注意事项。</p><h4 id="4-1-注意事项"><a href="#4-1-注意事项" class="headerlink" title="4.1. 注意事项"></a>4.1. 注意事项</h4><p>进入 博客文件夹\node_modules\hexo 路径中，打开 package.json 文件，便可查看hexo的版本：</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog0-3.png" alt="hexo版本"></p><p>在此文章发布时，该hexo版本是大于 5.0 的。因此在获取 Fluid 主题的最新版本时，推荐按照 Fluid 用户手册中的方法一来获取最新版本，不然可能在安装主题后执行：</p><div class="code-wrapper"><pre><code class="hljs bash">hexo s</code></pre></div><p>时，Fluid 主题会产生一个警告，按照方法一安装，则完美运行。</p><h2 id="5-将博客发布至-GitHub"><a href="#5-将博客发布至-GitHub" class="headerlink" title="5.将博客发布至 GitHub"></a>5.将博客发布至 GitHub</h2><p>完成此步骤，将会把个人博客部署至GitHub，实现在线浏览。</p><h3 id="5-1-在GitHub新建仓库"><a href="#5-1-在GitHub新建仓库" class="headerlink" title="5.1. 在GitHub新建仓库"></a>5.1. 在GitHub新建仓库</h3><p>在浏览器打开GitHub，登录后创建一个新仓库（Repository）：</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog0-4.png" alt="新仓库"></p><p>注意，仓库名必须要以你的用户名为开头，后跟 .github.io 。</p><p>最后滑到最下方点击 New Repository，则仓库创建成功。</p><h3 id="5-2-在博客目录下安装Git部署依赖"><a href="#5-2-在博客目录下安装Git部署依赖" class="headerlink" title="5.2. 在博客目录下安装Git部署依赖"></a>5.2. 在博客目录下安装Git部署依赖</h3><p>打开命令行，输入：</p><div class="code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> 博客目录路径</code></pre></div><p>进入博客目录。</p><p>随后，输入：</p><div class="code-wrapper"><pre><code class="hljs bash">$ npm install hexo-deployer-git --save</code></pre></div><p>来安装 Hexo 的 Git 部署工具。</p><h3 id="5-3-编辑博客目录下的-config-yml-文件"><a href="#5-3-编辑博客目录下的-config-yml-文件" class="headerlink" title="5.3. 编辑博客目录下的 _config.yml 文件"></a>5.3. 编辑博客目录下的 _config.yml 文件</h3><p>打开博客主目录下的 _config.yml 文件，找到 deploy 属性，进行如下图编辑：</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog0-5.png" alt="config文件编辑"></p><p>其中，repo 处填写创建项目的地址：</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog0-6.png" alt="地址"></p><p>编辑完成后，保存并关闭。</p><h3 id="5-4-将博客部署至GitHub"><a href="#5-4-将博客部署至GitHub" class="headerlink" title="5.4. 将博客部署至GitHub"></a>5.4. 将博客部署至GitHub</h3><p>打开命令行工具，移动到博客目录，输入：</p><div class="code-wrapper"><pre><code class="hljs bash">$ hexo d</code></pre></div><p>随后在弹出的图形界面或命令行界面输入GitHub的账号密码即可完成部署。</p><p>最后，在浏览器地址栏输入仓库名即可访问博客。</p>]]></content>
    
    
    <categories>
      
      <category>静态博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>hexo-fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
