<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据结构与算法复习（一）</title>
    <link href="/2021/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2021/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>通过数据结构与算法相关课程、书籍和LeetCode，来进行数据结构与算法复习。</p><span id="more"></span><p>本篇文章用于简要梳理在数据结构与算法复习过程中的一些重要知识点和难点，其中一些比较基础且在书中提及的知识点会忽略，因此并不适合仅仅通过阅读此文章来完成数据结构与算法的学习或复习，而是搭配以下资源进行阅读：</p><p><a href="https://dsa.cs.tsinghua.edu.cn/~deng/ds/index.htm">数据结构（邓俊辉）</a></p><p><a href="https://leetcode-cn.com/">LeetCode</a></p><h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><p><strong>To measure is to know. If you can not measure it, you can not improve it.</strong></p><p>本部分通过引入理想、统一、分层次的尺度标准，来衡量算法的性能。</p><h2 id="大O记号"><a href="#大O记号" class="headerlink" title="大O记号"></a>大O记号</h2><p>大O记号通过划分上界，来悲观地衡量一个算法的性能。</p><p>注意：O(f(n)) 并不一定会完全处于 T(n) 之上，但可以通过如图中对 f(n) 乘以常系数 c 来做到拉高上界的作用。</p><p>![大O记号](C:\Users\96129\OneDrive\Markdown Files\Blog\img\blog1\blog1-0.png)</p><h2 id="其它记号"><a href="#其它记号" class="headerlink" title="其它记号"></a>其它记号</h2><p>![其他记号](C:\Users\96129\OneDrive\Markdown Files\Blog\img\blog1\blog1-1.png)</p><h2 id="大O记号的刻度"><a href="#大O记号的刻度" class="headerlink" title="大O记号的刻度"></a>大O记号的刻度</h2><p><strong>常数复杂度 O( 1 )</strong></p><p>算法不含随输入规模变换的转向（循环、调用、递归等），且顺序执行，则说这个算法的复杂度为 O(1)。</p><p><strong>对数复杂度 O( log^c(n) )</strong></p><p>在此种情况中，对数的底数常常会被忽略，因为往往可以通过数学变换来改变对数的底数。</p><p>![底数变换](C:\Users\96129\OneDrive\Markdown Files\Blog\img\blog1\blog1-2.png)</p><p>这类算法非常高效，复杂度无限接近于常数。</p><p><strong>多项式复杂度 O( n^c )</strong></p><p>此种复杂度由于影响因素往往取决于最高次幂项，因此较低次幂的项往往忽略不计。</p><p>![多项式复杂度](C:\Users\96129\OneDrive\Markdown Files\Blog\img\blog1\blog1-3.png)</p><p>其中，当幂次 c == 1 时，表示算法的时间复杂度与 n 线性相关，因此称 O(n) 为线性复杂度。</p><p><strong>指数复杂度 O( 2^n )</strong></p><p>当一个算法的计算成本按指数增长时，往往我们认为此种算法为问题的难解。</p><p>![指数复杂度](C:\Users\96129\OneDrive\Markdown Files\Blog\img\blog1\blog1-4.png)</p><p>我们可以从下图中观察各个复杂度的增长速度：</p><p>![复杂度的增长速度](C:\Users\96129\OneDrive\Markdown Files\Blog\img\blog1\blog1-5.png)</p><h2 id="级数"><a href="#级数" class="headerlink" title="级数"></a>级数</h2><p>以下图片总结了一些常见的级数。</p><p>![级数1](C:\Users\96129\OneDrive\Markdown Files\Blog\img\blog1\blog1-6.png)</p><p>![级数2](C:\Users\96129\OneDrive\Markdown Files\Blog\img\blog1\blog1-7.png)</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>课程通过冒泡排序来描述一个算法的可行性以及算法的好坏对计算效率的影响，此处将简要描述冒泡排序。</p><p>![冒泡排序](C:\Users\96129\OneDrive\Markdown Files\Blog\img\blog1\blog1-8.png)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 冒泡排序</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BubbleSort</span> </span>&#123;<br><br>    <span class="hljs-comment">// 课程演示中冒泡排序的写法，因增加了反转判断，平均效率更高</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">boolean</span> sorted = <span class="hljs-keyword">false</span>; sorted = !sorted; n--) &#123; <span class="hljs-comment">// 每次遍历数组后对sorted进行反转来查看是否排序完成</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] &lt; nums[i - <span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-keyword">int</span> temp = nums[i];<br>                    nums[i] = nums[i - <span class="hljs-number">1</span>];<br>                    nums[i - <span class="hljs-number">1</span>] = temp;<br>                    sorted = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 如果数组中仍有反转，说明排序未完成</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 常规冒泡排序写法，效率较低</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n - i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (nums[j - <span class="hljs-number">1</span>] &gt; nums[j]) &#123;<br>                    <span class="hljs-keyword">int</span> temp = nums[j];<br>                    nums[j] = nums[j - <span class="hljs-number">1</span>];<br>                    nums[j - <span class="hljs-number">1</span>] = temp;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="迭代与递归"><a href="#迭代与递归" class="headerlink" title="迭代与递归"></a>迭代与递归</h1><p>本部分通过<strong>简要</strong>介绍减治法、分治法和动态规划，来体现迭代和递归。</p><p>注意：此部分不会详细讲述上述三种算法。</p><h2 id="减治法"><a href="#减治法" class="headerlink" title="减治法"></a>减治法</h2><p>通过将一个大规模的问题分解为两个子问题，<strong>将其中一个子问题解决</strong>，此后递归减治另一子问题，由子问题的解得到原问题的解。</p><p>![减治法](C:\Users\96129\OneDrive\Markdown Files\Blog\img\blog1\blog1-9.png)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 求和、数组翻转</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <br>    <span class="hljs-comment">// 减治法递归求和</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">1</span> ? sum(nums, n - <span class="hljs-number">1</span>) + nums[n - <span class="hljs-number">1</span>] : nums[n - <span class="hljs-number">1</span>];<br>    &#125;<br>    <br>    <span class="hljs-comment">// 减治法递归翻转数组</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (begin &lt; end) &#123;<br>            <span class="hljs-keyword">int</span> temp = nums[begin];<br>            nums[begin] = nums[end];<br>            nums[end] = temp;<br>            reverse(nums, begin + <span class="hljs-number">1</span>, end - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h2><p>通过将一个大规模的问题分解为两个子问题，并不断分解其子问题，直到最新的子问题得到解决后，依次得到原问题的解。</p><p>![分治法](C:\Users\96129\OneDrive\Markdown Files\Blog\img\blog1\blog1-10.png)</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>自底向上，通过先求出子问题来推出原问题的解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 斐波那契数列</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FB</span> </span>&#123;<br>    <br>    <span class="hljs-comment">// 分治 O(2^n)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">1</span> ? fib(n - <span class="hljs-number">1</span>) + fib(n - <span class="hljs-number">2</span>) : n;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 动态规划 O(n)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> f = <span class="hljs-number">0</span>; <span class="hljs-comment">// fib(0)</span><br>        <span class="hljs-keyword">int</span> g = <span class="hljs-number">1</span>; <span class="hljs-comment">// fib(1)</span><br>        <span class="hljs-keyword">while</span> (n-- &gt; <span class="hljs-number">1</span>) &#123;<br>            g = g + f;<br>            f = g - f;<br>        &#125;<br>        <span class="hljs-keyword">return</span> g;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态规划典型例题：最长公共子序列"><a href="#动态规划典型例题：最长公共子序列" class="headerlink" title="动态规划典型例题：最长公共子序列"></a>动态规划典型例题：最长公共子序列</h3><p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">LeetCode：最长公共子序列</a></p><p>此处介绍了两种求得最长公共子序列的方法：分治法和动态规划。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 最长公共子序列</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LCS</span> </span>&#123;<br><br>    <span class="hljs-comment">// 分治法递归 O(2^n)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lcs1</span><span class="hljs-params">(String s1, String s2, <span class="hljs-keyword">int</span> l1, <span class="hljs-keyword">int</span> l2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-number">0</span> || l2 == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 递归基</span><br>        <span class="hljs-keyword">if</span> (s1.charAt(l1 - <span class="hljs-number">1</span>) == s2.charAt(l2 - <span class="hljs-number">1</span>)) &#123; <span class="hljs-comment">// 如果判断此处字符串相同，同时除去两个字符，结果 + 1</span><br>            <span class="hljs-keyword">return</span> lcs1(s1, s2, l1 - <span class="hljs-number">1</span>, l2 - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果此处字符串不相等，分两个方向寻找子序列</span><br>        <span class="hljs-keyword">int</span> result1 = lcs1(s1, s2, l1 - <span class="hljs-number">1</span>, l2);<br>        <span class="hljs-keyword">int</span> result2 = lcs1(s1, s2, l1, l2 - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 返回两个结果中比较大的值</span><br>        <span class="hljs-keyword">return</span> Math.max(result1, result2);<br>    &#125;<br><br>    <span class="hljs-comment">// 动态规划 O(s1.length * s2.length)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lcs2</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建一个dp表，用于记录动态规划过程中产生的中间结果，length + 1 确保每个数据位都可以进行取值操作</span><br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[s1.length() + <span class="hljs-number">1</span>][s2.length() + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; dp.length; i++) &#123;<br>            <span class="hljs-keyword">char</span> c1 = s1.charAt(i);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; dp[i].length; j++) &#123;<br>                <span class="hljs-keyword">char</span> c2 = s2.charAt(i);<br>                <span class="hljs-keyword">if</span> (c1 == c2) &#123;<br>                    <span class="hljs-comment">// 如果相等，取左上角的值并且 + 1，因为左上角的值一定是最长公共子序列的组成部分。</span><br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 如果不相等，取左和上中较大的值作为结果</span><br>                    dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回最终结果</span><br>        <span class="hljs-keyword">return</span> dp[s1.length()][s2.length()];<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>![最长公共子序列原理](C:\Users\96129\OneDrive\Markdown Files\Blog\img\blog1\blog1-11.png)</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法复习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Hexo博客框架搭建静态博客</title>
    <link href="/2021/04/06/%E4%BD%BF%E7%94%A8Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/04/06/%E4%BD%BF%E7%94%A8Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>本篇文章用于记录如何在 Windows 中使用 Hexo 博客框架搭建个人静态博客。</p><span id="more"></span><p>在该篇文章中，您将会看到：静态博客搭建相关技术简介、博客搭建流程、使用主题来美化博客，最后将博客发布至 GitHub。</p><p>一些碎语：</p><p>在不同的操作系统中搭建静态博客的方法大同小异，因此此篇文章步骤也基本适用于其它操作系统。</p><p>博客搭建过程中难免会遇到不同问题，您可能和本人一样有着轻微的强迫症，不容许搭建过程中产生半点冗余内容，不用担心，此博客的所有内容都汇集在一个文件夹中，若搭建过程中遇到难以解决的问题，直接干掉未搭建完成的博客文件夹即可，而且如果完全按照此文章进行博客创建，途中产生的警告可完全忽略。</p><p>个人在两种操作系统中都搭建过静态博客，由于文件系统和权限等原因，在 Linux 中的安装流程更为顺畅，但由于Windows环境下能更加方便地编写发布博客，因此最后选择了 Windows。</p><p>此后可能会写将博客部署到云服务器的操作流程，但这是后话了，此时先专注于本篇文章。</p><h1 id="相关内容简介"><a href="#相关内容简介" class="headerlink" title="相关内容简介"></a>相关内容简介</h1><p>对相关技术了解较深或不感兴趣可以跳过该部分。</p><p>该部分将会简要介绍搭建静态博客时所涉及到的部分术语和相关技术，仅做简要介绍，具体请自行进行搜索。</p><p><strong>动态博客和静态博客</strong></p><p>此处的两种术语表示了两种不同的博客搭建形式，基本类似于静态网站和动态网站的区别。</p><p>动态博客，是指具有前端和后端的动态博客网站，类似于 CSDN、博客园等博客论坛，可以实现网站代码编写和功能使用的分离，其灵活性、易用性和功能性相较于静态博客都比较高。</p><p>静态博客，是指使用纯前端的形式搭建的静态博客网站，由于没有后台管理，因此对静态博客的每一个操作都与代码耦合，更难使用且功能更少，并且缺少动态交互。</p><p><strong>Hexo</strong></p><p>Hexo 是一个快速、简洁且高效的静态博客框架。该框架基于Node.js运行环境，能够帮助我们快速地搭建静态博客。</p><p><strong>Node.js</strong></p><p>“Node.js is a JavaScript runtime built on Chrome’s V8 JavaScript Engine.”</p><p>Node.js 不是一门编程语言，而是基于Chrome V8引擎的JavaScript语言运行环境，是一种宿主环境，类似于浏览器。</p><p><strong>GitHub</strong></p><p>GitHub 是一个开源的软件项目托管平台，由于其使用 Git 作为版本库格式进行托管，因此被命名为 GitHub。</p><p><strong>Git</strong></p><p>Git 是目前世界上较为先进的分布式版本控制系统，通过 Git，您可以方便地对项目的改动进行记录，还可以与其他人进行协作编辑，从而实现对项目的版本进行管理。</p><h1 id="静态博客搭建流程（Windows）"><a href="#静态博客搭建流程（Windows）" class="headerlink" title="静态博客搭建流程（Windows）"></a>静态博客搭建流程（Windows）</h1><p>该部分将展示 Windows 10 系统下静态博客的搭建流程，其中省略了一些较为简单的操作步骤。</p><p><strong>强烈建议在管理员模式下的命令行执行该流程。</strong></p><h2 id="1-下载-Node-js-和-Git"><a href="#1-下载-Node-js-和-Git" class="headerlink" title="1. 下载 Node.js 和 Git"></a>1. 下载 Node.js 和 Git</h2><p>个人建议从官方网站下载最新版本的Node.js和Git。</p><p><a href="https://nodejs.org/">Node.js 官方网站</a></p><p><a href="https://git-scm.com/">Git 官方网站</a></p><p>关于 Node.js 和 Git 的详细安装和环境配置流程，由于不属于本篇的主要内容，且流程对后续步骤影响不大，故不再列出，您可自行进行搜索，或直接采用默认的安装选项安装即可，必须确保两者被成功安装。</p><p><strong>检查 Node.js 和 Git 是否安装以及配置成功</strong></p><p>打开 Windows 的命令行工具，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ node -v<br></code></pre></td></tr></table></figure><p>若弹出 Node.js 版本信息，说明 Node.js 安装成功。</p><p>输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git<br></code></pre></td></tr></table></figure><p>若弹出 Git 的命令使用说明，说明 Git 安装成功。</p><h2 id="2-通过-Node-js-的-npm-安装-Hexo"><a href="#2-通过-Node-js-的-npm-安装-Hexo" class="headerlink" title="2. 通过 Node.js 的 npm 安装 Hexo"></a>2. 通过 Node.js 的 npm 安装 Hexo</h2><p>完成此部分，您就基本准备好了博客搭建所需要的工具。</p><p><strong>npm</strong></p><p>Node.js 的包管理器，允许客户从npm服务器中下载第三方的包到本地使用。在 Node.js 安装时自带。</p><h3 id="2-1-安装-cnpm（可选）"><a href="#2-1-安装-cnpm（可选）" class="headerlink" title="2.1. 安装 cnpm（可选）"></a>2.1. 安装 cnpm（可选）</h3><p>由于 npm 的镜像位于国外，因此下载速度较慢，cnpm 是中国的 npm 镜像客户端，此处将 cnpm 的镜像源指向淘宝的镜像源，后续的 npm 命令可以使用 cnpm 代替，npm 命令的详细含义可自行百度搜索，此处不再列出。</p><p>若您对所处的网络环境很自信，或者有 VPN，觉得没有这个必要，可跳过此步骤。</p><p>进入 Windows 命令行工具，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install -g cnpm --registry=https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><p>此后，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ cnpm<br></code></pre></td></tr></table></figure><p>若弹出 cnpm 的命令使用说明，说明 cnpm 安装成功。</p><p>此处 cnpm 被安装在 npm 的默认路径，您可以通过修改此路径来统一管理包。</p><h3 id="2-2-安装Hexo"><a href="#2-2-安装Hexo" class="headerlink" title="2.2. 安装Hexo"></a>2.2. 安装Hexo</h3><p><strong>若您安装了 cnpm，将下面的 npm 改为 cnpm 即可。</strong></p><p>打开 Windows 命令行，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>此后，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo -v<br></code></pre></td></tr></table></figure><p>来验证 Hexo 框架是否安装完成。</p><h2 id="3-使用-Hexo-搭建并查看本地网站"><a href="#3-使用-Hexo-搭建并查看本地网站" class="headerlink" title="3. 使用 Hexo 搭建并查看本地网站"></a>3. 使用 Hexo 搭建并查看本地网站</h2><p>完成此部分，您可以获得一个默认的博客网站。</p><h3 id="3-1-在指定路径创建博客文件夹"><a href="#3-1-在指定路径创建博客文件夹" class="headerlink" title="3.1. 在指定路径创建博客文件夹"></a>3.1. 在指定路径创建博客文件夹</h3><p>在您喜欢的路径上创建一个 Blog 文件夹后，在命令行输入（以下命令仅是示例，请按照此格式更改为您自己的文件夹）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> C:\Code\Blog<br></code></pre></td></tr></table></figure><p>便可跳转到此文件夹中。</p><h3 id="3-2-使用-Hexo-生成博客"><a href="#3-2-使用-Hexo-生成博客" class="headerlink" title="3.2. 使用 Hexo 生成博客"></a>3.2. 使用 Hexo 生成博客</h3><p>执行步骤3.1后，在命令行输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo init<br></code></pre></td></tr></table></figure><p>来生成一个默认的新博客。</p><p><strong>您可能会遇到以下错误：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog0-0.png" alt="错误报告"></p><p>这是因为连接 GitHub 超时，您可以使用 VPN、更换网络或稍后再试。</p><p><strong>当最后一行出现：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">INFO Start blogging with Hexo!<br></code></pre></td></tr></table></figure><p>说明博客生成成功。</p><h3 id="3-3-本地查看网站"><a href="#3-3-本地查看网站" class="headerlink" title="3.3. 本地查看网站"></a>3.3. 本地查看网站</h3><p>在命令行输入（注意，务必在自己创建的博客目录下输入这条命令）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo s<br></code></pre></td></tr></table></figure><p>即可启动本地博客，默认地址一般为：<a href="http://localhost:4000/">http://localhost:4000/</a> 。您可在启动后展示的信息中找到此地址（黄色部分）：</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog0-1.png" alt="localhost"></p><p>该端口可能会被占用，此时修改默认启用的端口即可。</p><p>随后打开浏览器，输入该地址，您便会看到一个默认的博客页面：</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog0-2.png" alt="默认界面"></p><p>至此，博客便已搭建成功。</p><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>在<a href="https://hexo.io/zh-cn/docs/"> Hexo 官方文档 </a>中的Hexo概述中有这么一段话：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">安装 Hexo<br>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。<br>$ npm install -g hexo-cli<br><br>进阶安装和使用<br>对于熟悉 npm 的进阶用户，可以仅局部安装 hexo 包。<br>$ npm install hexo<br></code></pre></td></tr></table></figure><p><strong>那么 Hexo 和 Hexo-cli 有什么区别呢？</strong></p><p>hexo 包是基于 Node.js 的一个静态博客生成工具。而 hexo-cli 包则将 hexo 包中的功能封装为一个命令行工具。</p><p>换句话说：hexo-cli == Hexo Command Line Interface</p><p>例如，在执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init blog<br></code></pre></td></tr></table></figure><p>的时候，hexo-cli 会自动从 GitHub 中下载 hexo 到博客文件夹的 node_modules 目录下。</p><p>此外，上述流程中的 hexo 相关命令都是由于 hexo-cli 进行了封装，才能使用。</p><h2 id="4-使用Fluid主题美化博客"><a href="#4-使用Fluid主题美化博客" class="headerlink" title="4. 使用Fluid主题美化博客"></a>4. 使用Fluid主题美化博客</h2><p>完成此步骤，您将获得一个搭载了默认 Fluid 主题的静态博客。</p><p><img src="https://camo.githubusercontent.com/48b250de82787ee8090df0e3a3088e10d09a12b58fe1df55045f2476aca20978/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666c7569642d6465762f737461746963406d61737465722f6865786f2d7468656d652d666c7569642f73637265656e73686f74732f696e6465782e706e67" alt="Fluid主题预览"></p><p>该主题有详尽的中文用户手册，可自行进入 <a href="https://hexo.fluid-dev.com/docs/">Hexo Fluid 用户手册</a> 来添加该主题，以下仅提供一些注意事项。</p><h4 id="4-1-注意事项"><a href="#4-1-注意事项" class="headerlink" title="4.1. 注意事项"></a>4.1. 注意事项</h4><p>进入 博客文件夹\node_modules\hexo 路径中，打开 package.json 文件，便可查看hexo的版本：</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog0-3.png" alt="hexo版本"></p><p>在此文章发布时，该hexo版本是大于 5.0 的。因此在获取 Fluid 主题的最新版本时，推荐按照 Fluid 用户手册中的方法一来获取最新版本，不然可能在安装主题后执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo s<br></code></pre></td></tr></table></figure><p>时，Fluid 主题会产生一个警告，按照方法一安装，则完美运行。</p><h2 id="5-将博客发布至-GitHub"><a href="#5-将博客发布至-GitHub" class="headerlink" title="5.将博客发布至 GitHub"></a>5.将博客发布至 GitHub</h2><p>完成此步骤，将会把个人博客部署至GitHub，实现在线浏览。</p><h3 id="5-1-在GitHub新建仓库"><a href="#5-1-在GitHub新建仓库" class="headerlink" title="5.1. 在GitHub新建仓库"></a>5.1. 在GitHub新建仓库</h3><p>在浏览器打开GitHub，登录后创建一个新仓库（Repository）：</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog0-4.png" alt="新仓库"></p><p>注意，仓库名必须要以你的用户名为开头，后跟 .github.io 。</p><p>最后滑到最下方点击 New Repository，则仓库创建成功。</p><h3 id="5-2-在博客目录下安装Git部署依赖"><a href="#5-2-在博客目录下安装Git部署依赖" class="headerlink" title="5.2. 在博客目录下安装Git部署依赖"></a>5.2. 在博客目录下安装Git部署依赖</h3><p>打开命令行，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> 博客目录路径<br></code></pre></td></tr></table></figure><p>进入博客目录。</p><p>随后，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>来安装 Hexo 的 Git 部署工具。</p><h3 id="5-3-编辑博客目录下的-config-yml-文件"><a href="#5-3-编辑博客目录下的-config-yml-文件" class="headerlink" title="5.3. 编辑博客目录下的 _config.yml 文件"></a>5.3. 编辑博客目录下的 _config.yml 文件</h3><p>打开博客主目录下的 _config.yml 文件，找到 deploy 属性，进行如下图编辑：</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog0-5.png" alt="config文件编辑"></p><p>其中，repo 处填写创建项目的地址：</p><p><img src="https://cdn.jsdelivr.net/gh/RoOtZwY/github-img/img/blog0-6.png" alt="地址"></p><p>编辑完成后，保存并关闭。</p><h3 id="5-4-将博客部署至GitHub"><a href="#5-4-将博客部署至GitHub" class="headerlink" title="5.4. 将博客部署至GitHub"></a>5.4. 将博客部署至GitHub</h3><p>打开命令行工具，移动到博客目录，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo d<br></code></pre></td></tr></table></figure><p>随后在弹出的图形界面或命令行界面输入GitHub的账号密码即可完成部署。</p><p>最后，在浏览器地址栏输入仓库名即可访问博客。</p>]]></content>
    
    
    <categories>
      
      <category>静态博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>hexo-fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
